/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _router1 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar prefetched = {\n};\nfunction prefetch(router, href, as, options) {\n    if ( false || !router) return;\n    if (!(0, _router).isLocalURL(href)) return;\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    router.prefetch(href, as, options).catch(function(err) {\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n    var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale;\n    // Join on an invalid URI character\n    prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;\n}\nfunction isModifiedEvent(event) {\n    var target = event.currentTarget.target;\n    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n    var nodeName = e.currentTarget.nodeName;\n    if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n        // ignore click for browserâ€™s default behavior\n        return;\n    }\n    e.preventDefault();\n    //  avoid scroll for urls with anchor refs\n    if (scroll == null && as.indexOf('#') >= 0) {\n        scroll = false;\n    }\n    // replace state instead of push if prop is present\n    router[replace ? 'replace' : 'push'](href, as, {\n        shallow: shallow,\n        locale: locale,\n        scroll: scroll\n    });\n}\nfunction Link(props) {\n    _s1();\n    if (true) {\n        var createPropError = function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        };\n        // TypeScript trick for type-guarding:\n        var requiredPropsGuard = {\n            href: true\n        };\n        var requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach(function(key) {\n            if (key === 'href') {\n                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n                    throw createPropError({\n                        key: key,\n                        expected: '`string` or `object`',\n                        actual: props[key] === null ? 'null' : _typeof(props[key])\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        var optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true\n        };\n        var optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach(function(key) {\n            var valType = _typeof(props[key]);\n            if (key === 'as') {\n                if (props[key] && valType !== 'string' && valType !== 'object') {\n                    throw createPropError({\n                        key: key,\n                        expected: '`string` or `object`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'locale') {\n                if (props[key] && valType !== 'string') {\n                    throw createPropError({\n                        key: key,\n                        expected: '`string`',\n                        actual: valType\n                    });\n                }\n            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {\n                if (props[key] != null && valType !== 'boolean') {\n                    throw createPropError({\n                        key: key,\n                        expected: '`boolean`',\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        var hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n        }\n    }\n    var p = props.prefetch !== false;\n    var router = (0, _router1).useRouter();\n    var ref2 = _react.default.useMemo(function() {\n        var ref = _slicedToArray((0, _router).resolveHref(router, props.href, true), 2), resolvedHref = ref[0], resolvedAs = ref[1];\n        return {\n            href: resolvedHref,\n            as: props.as ? (0, _router).resolveHref(router, props.as) : resolvedAs || resolvedHref\n        };\n    }, [\n        router,\n        props.href,\n        props.as\n    ]), href = ref2.href, as = ref2.as;\n    var children = props.children, replace = props.replace, shallow = props.shallow, scroll = props.scroll, locale = props.locale;\n    // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n    if (typeof children === 'string') {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    // This will return the first child, if multiple are provided it will throw an error\n    var child;\n    if (true) {\n        try {\n            child = _react.default.Children.only(children);\n        } catch (err) {\n            throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(props.href, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n    } else {}\n    var childRef = child && typeof child === 'object' && child.ref;\n    var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n        rootMargin: '200px'\n    }), 2), setIntersectionRef = ref1[0], isVisible = ref1[1];\n    var setRef = _react.default.useCallback(function(el) {\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === 'function') childRef(el);\n            else if (typeof childRef === 'object') {\n                childRef.current = el;\n            }\n        }\n    }, [\n        childRef,\n        setIntersectionRef\n    ]);\n    _react.default.useEffect(function() {\n        var shouldPrefetch = isVisible && p && (0, _router).isLocalURL(href);\n        var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;\n        var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];\n        if (shouldPrefetch && !isPrefetched) {\n            prefetch(router, href, as, {\n                locale: curLocale\n            });\n        }\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        p,\n        router\n    ]);\n    var childProps = {\n        ref: setRef,\n        onClick: function(e) {\n            if (child.props && typeof child.props.onClick === 'function') {\n                child.props.onClick(e);\n            }\n            if (!e.defaultPrevented) {\n                linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n            }\n        }\n    };\n    childProps.onMouseEnter = function(e) {\n        if (!(0, _router).isLocalURL(href)) return;\n        if (child.props && typeof child.props.onMouseEnter === 'function') {\n            child.props.onMouseEnter(e);\n        }\n        prefetch(router, href, as, {\n            priority: true\n        });\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user\n    if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n        var curLocale1 = typeof locale !== 'undefined' ? locale : router && router.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        var localeDomain = router && router.isLocaleDomain && (0, _router).getDomainLocale(as, curLocale1, router && router.locales, router && router.domainLocales);\n        childProps.href = localeDomain || (0, _router).addBasePath((0, _router).addLocale(as, curLocale1, router && router.defaultLocale));\n    }\n    return(/*#__PURE__*/ _react.default.cloneElement(child, childProps));\n}\n_s1(Link, \"ugPujB1zuGRzOKQKTT+IQY94kgY=\");\n_c = Link;\nvar _default = Link;\nexports[\"default\"] = _default; //# sourceMappingURL=link.js.map\nvar _c;\n$RefreshReg$(_c, \"Link\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3hCLEdBQUcsQ0FBQ0csTUFBTSxHQUFHQyxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUNuRCxHQUFHLENBQUNDLE9BQU8sR0FBR0QsbUJBQU8sQ0FBQyx5RkFBNkI7QUFDbkQsR0FBRyxDQUFDRSxRQUFRLEdBQUdGLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsR0FBRyxDQUFDRyxnQkFBZ0IsR0FBR0gsbUJBQU8sQ0FBQywrRUFBb0I7U0FDMUNELHNCQUFzQixDQUFDSyxHQUFHLEVBQUUsQ0FBQztJQUNsQyxNQUFNLENBQUNBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRyxDQUFDO1FBQ2xDUCxPQUFPLEVBQUVPLEdBQUc7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxHQUFLLENBQUNFLFVBQVUsR0FBRyxDQUFDO0FBQ3BCLENBQUM7U0FDUUMsUUFBUSxDQUFDQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFQyxPQUFPLEVBQUUsQ0FBQztJQUMxQyxFQUFFLEVBQUUsTUFBNkIsS0FBS0gsTUFBTSxFQUFFLE1BQU07SUFDcEQsRUFBRSxJQUFJLENBQUMsRUFBRVAsT0FBTyxFQUFFVyxVQUFVLENBQUNILElBQUksR0FBRyxNQUFNO0lBQzFDLEVBQXVEO0lBQ3ZELEVBQTBEO0lBQzFELEVBQXNEO0lBQ3RELEVBQXlEO0lBQ3pERCxNQUFNLENBQUNELFFBQVEsQ0FBQ0UsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUUsS0FBSyxDQUFDLFFBQVEsQ0FBUEMsR0FBRyxFQUFH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ZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyXCIpO1xudmFyIF9yb3V0ZXIxID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF91c2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3QgcHJlZmV0Y2hlZCA9IHtcbn07XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFyb3V0ZXIpIHJldHVybjtcbiAgICBpZiAoISgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpKSByZXR1cm47XG4gICAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjdXJMb2NhbGUgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gICAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXSA9IHRydWU7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHRhcmdldCAgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcbn1cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSAgfSA9IGUuY3VycmVudFRhcmdldDtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAgICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICAgIGlmIChzY3JvbGwgPT0gbnVsbCAmJiBhcy5pbmRleE9mKCcjJykgPj0gMCkge1xuICAgICAgICBzY3JvbGwgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gICAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7XG4gICAgICAgIHNoYWxsb3csXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgc2Nyb2xsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBMaW5rKHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7XG4gICAgICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdhcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsb2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmVwbGFjZScgfHwga2V5ID09PSAnc2Nyb2xsJyB8fCBrZXkgPT09ICdzaGFsbG93JyB8fCBrZXkgPT09ICdwYXNzSHJlZicgfHwga2V5ID09PSAncHJlZmV0Y2gnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHAgPSBwcm9wcy5wcmVmZXRjaCAhPT0gZmFsc2U7XG4gICAgY29uc3Qgcm91dGVyID0gKDAsIF9yb3V0ZXIxKS51c2VSb3V0ZXIoKTtcbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocm91dGVyLCBwcm9wcy5ocmVmLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGFzOiBwcm9wcy5hcyA/ICgwLCBfcm91dGVyKS5yZXNvbHZlSHJlZihyb3V0ZXIsIHByb3BzLmFzKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIHByb3BzLmhyZWYsXG4gICAgICAgIHByb3BzLmFzXG4gICAgXSk7XG4gICAgbGV0IHsgY2hpbGRyZW4gLCByZXBsYWNlICwgc2hhbGxvdyAsIHNjcm9sbCAsIGxvY2FsZSAgfSA9IHByb3BzO1xuICAgIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZHJlbiBwcm92aWRlZCBpcyBhIHN0cmluZyAoPExpbms+ZXhhbXBsZTwvTGluaz4pIHdlIHdyYXAgaXQgaW4gYW4gPGE+IHRhZ1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7cHJvcHMuaHJlZn1cXGAgYnV0IG9ubHkgb25lIGNoaWxkIGlzIHN1cHBvcnRlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW11bHRpcGxlLWNoaWxkcmVuYCArICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFwiIFxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiAnJykpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGVdID0gKDAsIF91c2VJbnRlcnNlY3Rpb24pLnVzZUludGVyc2VjdGlvbih7XG4gICAgICAgIHJvb3RNYXJnaW46ICcyMDBweCdcbiAgICB9KTtcbiAgICBjb25zdCBzZXRSZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgY2hpbGRSZWYsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBjb25zdCBzaG91bGRQcmVmZXRjaCA9IGlzVmlzaWJsZSAmJiBwICYmICgwLCBfcm91dGVyKS5pc0xvY2FsVVJMKGhyZWYpO1xuICAgICAgICBjb25zdCBjdXJMb2NhbGUgPSB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlO1xuICAgICAgICBjb25zdCBpc1ByZWZldGNoZWQgPSBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhcyArIChjdXJMb2NhbGUgPyAnJScgKyBjdXJMb2NhbGUgOiAnJyldO1xuICAgICAgICBpZiAoc2hvdWxkUHJlZmV0Y2ggJiYgIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZTogY3VyTG9jYWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBwLFxuICAgICAgICByb3V0ZXJcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljazogKGUpPT57XG4gICAgICAgICAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKGUpPT57XG4gICAgICAgIGlmICghKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpIHJldHVybjtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBwcmlvcml0eTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICAgIGlmIChwcm9wcy5wYXNzSHJlZiB8fCBjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGU7XG4gICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgICAgIC8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG4gICAgICAgIGNvbnN0IGxvY2FsZURvbWFpbiA9IHJvdXRlciAmJiByb3V0ZXIuaXNMb2NhbGVEb21haW4gJiYgKDAsIF9yb3V0ZXIpLmdldERvbWFpbkxvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZXMsIHJvdXRlciAmJiByb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX3JvdXRlcikuYWRkQmFzZVBhdGgoKDAsIF9yb3V0ZXIpLmFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSk7XG59XG52YXIgX2RlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3JvdXRlciIsIl9yb3V0ZXIxIiwiX3VzZUludGVyc2VjdGlvbiIsIm9iaiIsIl9fZXNNb2R1bGUiLCJwcmVmZXRjaGVkIiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiaXNMb2NhbFVSTCIsImNhdGNoIiwiZXJyIiwiY3VyTG9jYWxlIiwibG9jYWxlIiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJ0YXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsIm5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJpbmRleE9mIiwiTGluayIsInByb3BzIiwiY3JlYXRlUHJvcEVycm9yIiwiYXJncyIsIkVycm9yIiwia2V5IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJyZXF1aXJlZFByb3BzR3VhcmQiLCJyZXF1aXJlZFByb3BzIiwia2V5cyIsImZvckVhY2giLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwicGFzc0hyZWYiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsInVzZVJlZiIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsInAiLCJ1c2VSb3V0ZXIiLCJ1c2VNZW1vIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZFJlZiIsInJlZiIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJpc1Zpc2libGUiLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwidXNlRWZmZWN0Iiwic2hvdWxkUHJlZmV0Y2giLCJpc1ByZWZldGNoZWQiLCJjaGlsZFByb3BzIiwib25DbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbk1vdXNlRW50ZXIiLCJwcmlvcml0eSIsInR5cGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\nfunction useIntersection(param) {\n    var rootMargin = param.rootMargin, disabled = param.disabled;\n    _s1();\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var unobserve = (0, _react).useRef();\n    var ref = _slicedToArray((0, _react).useState(false), 2), visible = ref[0], setVisible = ref[1];\n    var setRef = (0, _react).useCallback(function(el) {\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, function(isVisible) {\n                return isVisible && setVisible(isVisible);\n            }, {\n                rootMargin: rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        rootMargin,\n        visible\n    ]);\n    (0, _react).useEffect(function() {\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n                };\n            }\n        }\n    }, [\n        visible\n    ]);\n    return [\n        setRef,\n        visible\n    ];\n}\n_s1(useIntersection, \"Z6jj7qx+KE6gD9CpC9WlQTha45o=\");\nfunction observe(element, callback, options) {\n    var ref = createObserver(options), id = ref.id, observer = ref.observer, elements = ref.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n        }\n    };\n}\nvar observers = new Map();\nfunction createObserver(options) {\n    var id = options.rootMargin || '';\n    var instance = observers.get(id);\n    if (instance) {\n        return instance;\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    });\n    return instance;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0UsZUFBZTtBQUN6QyxHQUFHLENBQUNDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBTztBQUM1QixHQUFHLENBQUNDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUF5QjtBQUM1RCxHQUFLLENBQUNFLHVCQUF1QixHQUFHLE1BQU0sQ0FBQ0Msb0JBQW9CLEtBQUssQ0FBVztTQUNsRUwsZUFBZSxDQUFDLEtBQTBCLEVBQUUsQ0FBQztRQUEzQk0sVUFBVSxHQUFaLEtBQTBCLENBQXhCQSxVQUFVLEVBQUdDLFFBQVEsR0FBdkIsS0FBMEIsQ0FBWEEsUUFBUTs7SUFDNUMsR0FBSyxDQUFDQyxVQUFVLEdBQUdELFFBQVEsS0FBS0gsdUJBQXVCO0lBQ3ZELEdBQUssQ0FBQ0ssU0FBUyxJQUFJLENBQUMsRUFBRVIsTUFBTSxFQUFFUyxNQUFNO0lBQ3BDLEdBQUssQ0FBeUIsR0FBMkIsbUJBQTFCLENBQUMsRUFBRVQsTUFBTSxFQUFFVSxRQUFRLENBQUMsS0FBSyxPQUFqREMsT0FBTyxHQUFnQixHQUEyQixLQUF6Q0MsVUFBVSxHQUFJLEdBQTJCO0lBQ3pELEdBQUssQ0FBQ0MsTUFBTSxJQUFJLENBQUMsRUFBRWIsTUFBTSxFQUFFYyxXQUFXLENBQUMsUUFDM0MsQ0FENENDLEVBQUUsRUFBRyxDQUFDO1FBQzFDLEVBQUUsRUFBRVAsU0FBUyxDQUFDUSxPQUFPLEVBQUUsQ0FBQztZQUNwQlIsU0FBUyxDQUFDUSxPQUFPO1lBQ2pCUixTQUFTLENBQUNRLE9BQU8sR0FBR0MsU0FBUztRQUNqQyxDQUFDO1FBQ0QsRUFBRSxFQUFFVixVQUFVLElBQUlJLE9B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QUFDdkIsU0FBUyxHQUFHc0IsS0FBSyxDQUFDRSxjQUFjLElBQUlGLEtBQUssQ0FBQ0csaUJBQWlCLEdBQUcsQ0FBQztZQUNyRSxFQUFFLEVBQUVuQixRQUFRLElBQUlOLFNBQVMsRUFBRSxDQUFDO2dCQUN4Qk0sUUFBUSxDQUFDTixTQUFTO1lBQ3RCLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQyxFQUFFTyxPQUFPO0lBQ1ZTLFNBQVMsQ0FBQ0osR0FBRyxDQUFDSCxFQUFFLEVBQUVTLFFBQVEsR0FBRyxDQUFDO1FBQzFCVCxFQUFFLEVBQUZBLEVBQUU7UUFDRkMsUUFBUSxFQUFSQSxRQUFRO1FBQ1JDLFFBQVEsRUFBUkEsUUFBUTtJQUNaLENBQUM7SUFDRCxNQUFNLENBQUNPLFFBQVE7QUFDbkIsQ0FBQyxDQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzP2ZkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZUludGVyc2VjdGlvbiA9IHVzZUludGVyc2VjdGlvbjtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX3JlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oeyByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzZXRSZWYgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIGlmICh1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgaWYgKGVsICYmIGVsLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShlbCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSlcbiAgICAgICAgICAgICwge1xuICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VmlzaWJsZSh0cnVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2V0UmVmLFxuICAgICAgICB2aXNpYmxlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnO1xuICAgIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInVub2JzZXJ2ZSIsInVzZVJlZiIsInVzZVN0YXRlIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJzZXRSZWYiLCJ1c2VDYWxsYmFjayIsImVsIiwiY3VycmVudCIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJvYnNlcnZlIiwiaXNWaXNpYmxlIiwidXNlRWZmZWN0IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjcmVhdGVPYnNlcnZlciIsImlkIiwib2JzZXJ2ZXIiLCJlbGVtZW50cyIsInNldCIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZXJzIiwiTWFwIiwiaW5zdGFuY2UiLCJnZXQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./node_modules/next/dist/pages/_app.js":
/*!**********************************************!*\
  !*** ./node_modules/next/dist/pages/_app.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar _runtimeJs = _interopRequireDefault(__webpack_require__(/*! ./node_modules/next/node_modules/regenerator-runtime/runtime.js */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\"));\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AppInitialProps\", ({\n    enumerable: true,\n    get: function get() {\n        return _utils.AppInitialProps;\n    }\n}));\nObject.defineProperty(exports, \"NextWebVitalsMetric\", ({\n    enumerable: true,\n    get: function get() {\n        return _utils.NextWebVitalsMetric;\n    }\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault1(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _interopRequireDefault1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _appGetInitialProps() {\n    _appGetInitialProps = /**\n * `App` component is used for initialize of pages. It allows for overwriting and full control of the `page` initialization.\n * This allows for keeping state between navigation, custom error handling, injecting additional data.\n */ _asyncToGenerator(_runtimeJs.default.mark(function _callee(param) {\n        var Component, ctx, pageProps;\n        return _runtimeJs.default.wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    Component = param.Component, ctx = param.ctx;\n                    _ctx.next = 3;\n                    return (0, _utils).loadGetInitialProps(Component, ctx);\n                case 3:\n                    pageProps = _ctx.sent;\n                    return _ctx.abrupt(\"return\", {\n                        pageProps: pageProps\n                    });\n                case 5:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return _appGetInitialProps.apply(this, arguments);\n}\nfunction appGetInitialProps(_) {\n    return _appGetInitialProps.apply(this, arguments);\n}\nvar App = /*#__PURE__*/ function(_Component) {\n    _inherits(App, _Component);\n    function App() {\n        _classCallCheck(this, App);\n        return _possibleConstructorReturn(this, _getPrototypeOf(App).apply(this, arguments));\n    }\n    _createClass(App, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _props = this.props, Component = _props.Component, pageProps = _props.pageProps;\n                return(/*#__PURE__*/ _react.default.createElement(Component, Object.assign({\n                }, pageProps)));\n            }\n        }\n    ]);\n    return App;\n}(_react.default.Component);\nApp.origGetInitialProps = appGetInitialProps;\nApp.getInitialProps = appGetInitialProps;\nexports[\"default\"] = App; //# sourceMappingURL=_app.js.map\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19hcHAuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGSCxtREFBa0QsQ0FBQztJQUMvQ0ksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxRQUFRLENBQWJBLEdBQUcsR0FBYSxDQUFDO1FBQ2IsTUFBTSxDQUFDQyxNQUFNLENBQUNDLGVBQWU7SUFDakMsQ0FBQztBQUNMLENBQUMsRUFBQztBQUNGUCx1REFBc0QsQ0FBQztJQUNuREksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxRQUFRLENBQWJBLEdBQUcsR0FBYSxDQUFDO1FBQ2IsTUFBTSxDQUFDQyxNQUFNLENBQUNFLG1CQUFtQjtJQUNyQyxDQUFDO0FBQ0wsQ0FBQyxFQUFDO0FBQ0ZOLGtCQUFlLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDeEIsR0FBRyxDQUFDUSxNQUFNLEdBQUdDLHVCQUFzQixDQUFDQyxtQkFBTyxDQUFDLDRDQUFPO0FBQ25ELEdBQUcsQ0FBQ04sTUFBTSxHQUFHTSxtQkFBTyxDQUFDLHlFQUFxQjtTQUNqQ0Msa0JBQWtCLENBQUNDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRSxDQUFDO0lBQ3hFLEdBQUcsQ0FBQyxDQUFDO1FBQ0QsR0FBRyxDQUFDQyxJQUFJLEdBQUdQLEdBQUcsQ0FBQ0ssR0FBRyxFQUFFQyxHQUFHO1FBQ3ZCLEdBQUcsQ0FBQ2pCLEtBQUssR0FBR2tCLElBQUksQ0FBQ2xCLEtBQUs7SUFDMUIsQ0FBQyxDQUFDLEtBQUssRUFBRW1CLEtBQUssRUFBRSxDQUFDO1FBQ2JOLE1BQU0s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RSxDQUFDLEVBQUVSLFNBQVM7WUFDaEIsQ0FBQzs7O1dBTENJLEdBQUc7RUFBU2pDLE1BQU0sQ0FBQ0QsT0FBTyxDQUFDNEIsU0FBUztBQU8xQ00sR0FBRyxDQUFDSyxtQkFBbUIsR0FBR1Asa0JBQWtCO0FBQzVDRSxHQUFHLENBQUNNLGVBQWUsR0FBR1Isa0JBQWtCO0FBQ3hDdkMsa0JBQWUsR0FBR3lDLEdBQUcsQ0FFckIsQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9wYWdlcy9fYXBwLmpzPzk2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcHBJbml0aWFsUHJvcHNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF91dGlscy5BcHBJbml0aWFsUHJvcHM7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXh0V2ViVml0YWxzTWV0cmljXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdXRpbHMuTmV4dFdlYlZpdGFsc01ldHJpYztcbiAgICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX2FwcEdldEluaXRpYWxQcm9wcygpIHtcbiAgICBfYXBwR2V0SW5pdGlhbFByb3BzID0gLyoqXG4gKiBgQXBwYCBjb21wb25lbnQgaXMgdXNlZCBmb3IgaW5pdGlhbGl6ZSBvZiBwYWdlcy4gSXQgYWxsb3dzIGZvciBvdmVyd3JpdGluZyBhbmQgZnVsbCBjb250cm9sIG9mIHRoZSBgcGFnZWAgaW5pdGlhbGl6YXRpb24uXG4gKiBUaGlzIGFsbG93cyBmb3Iga2VlcGluZyBzdGF0ZSBiZXR3ZWVuIG5hdmlnYXRpb24sIGN1c3RvbSBlcnJvciBoYW5kbGluZywgaW5qZWN0aW5nIGFkZGl0aW9uYWwgZGF0YS5cbiAqLyBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiooeyBDb21wb25lbnQgLCBjdHggIH0pIHtcbiAgICAgICAgY29uc3QgcGFnZVByb3BzID0geWllbGQgKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlUHJvcHNcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2FwcEdldEluaXRpYWxQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gYXBwR2V0SW5pdGlhbFByb3BzKF8pIHtcbiAgICByZXR1cm4gX2FwcEdldEluaXRpYWxQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuY2xhc3MgQXBwIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50ICwgcGFnZVByb3BzICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB9LCBwYWdlUHJvcHMpKSk7XG4gICAgfVxufVxuQXBwLm9yaWdHZXRJbml0aWFsUHJvcHMgPSBhcHBHZXRJbml0aWFsUHJvcHM7XG5BcHAuZ2V0SW5pdGlhbFByb3BzID0gYXBwR2V0SW5pdGlhbFByb3BzO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXBwLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfdXRpbHMiLCJBcHBJbml0aWFsUHJvcHMiLCJOZXh0V2ViVml0YWxzTWV0cmljIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93Iiwia2V5IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsInNlbGYiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2FwcEdldEluaXRpYWxQcm9wcyIsIkNvbXBvbmVudCIsImN0eCIsInBhZ2VQcm9wcyIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJhcHBHZXRJbml0aWFsUHJvcHMiLCJfIiwiQXBwIiwicmVuZGVyIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiYXNzaWduIiwib3JpZ0dldEluaXRpYWxQcm9wcyIsImdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/pages/_app.js\n");

/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MyApp; }\n/* harmony export */ });\n/* harmony import */ var _Users_janinezielman_Documents_Sites_Prismic_eyemove_node_modules_next_node_modules_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/regenerator-runtime/runtime.js */ \"./node_modules/next/node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var _Users_janinezielman_Documents_Sites_Prismic_eyemove_node_modules_next_node_modules_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_janinezielman_Documents_Sites_Prismic_eyemove_node_modules_next_node_modules_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _prismicio_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prismicio/client */ \"./node_modules/@prismicio/client/esm/@prismicio/client.mjs\");\n/* harmony import */ var next_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/app */ \"./node_modules/next/app.js\");\n/* harmony import */ var next_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _prismic_configuration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../prismic-configuration */ \"./prismic-configuration.js\");\n/* harmony import */ var _styles_globals_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/globals.scss */ \"./styles/globals.scss\");\n/* harmony import */ var _styles_globals_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_scss__WEBPACK_IMPORTED_MODULE_6__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\n\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nvar _typeof = function(obj) {\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar MyApp = /*#__PURE__*/ function(NextApp) {\n    \"use strict\";\n    _inherits(MyApp, NextApp);\n    function MyApp() {\n        _classCallCheck(this, MyApp);\n        return _possibleConstructorReturn(this, _getPrototypeOf(MyApp).apply(this, arguments));\n    }\n    _createClass(MyApp, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _props = this.props, Component = _props.Component, pageProps = _props.pageProps, props = _props.props;\n                return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Component, _objectSpread({\n                }, pageProps, {\n                    menu: props.menu,\n                    footer: props.footer,\n                    __source: {\n                        fileName: \"/Users/janinezielman/Documents/Sites/Prismic/eyemove/pages/_app.js\",\n                        lineNumber: 23,\n                        columnNumber: 7\n                    },\n                    __self: this\n                })));\n            }\n        }\n    ], [\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(appCtx) {\n                return _asyncToGenerator(_Users_janinezielman_Documents_Sites_Prismic_eyemove_node_modules_next_node_modules_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n                    var menu, footer;\n                    return _Users_janinezielman_Documents_Sites_Prismic_eyemove_node_modules_next_node_modules_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n                        while(1)switch(_ctx.prev = _ctx.next){\n                            case 0:\n                                _ctx.next = 2;\n                                return (0,_prismic_configuration__WEBPACK_IMPORTED_MODULE_5__.Client)().getSingle(\"menu\");\n                            case 2:\n                                _ctx.t0 = _ctx.sent;\n                                if (_ctx.t0) {\n                                    _ctx.next = 5;\n                                    break;\n                                }\n                                _ctx.t0 = {\n                                };\n                            case 5:\n                                menu = _ctx.t0;\n                                _ctx.next = 8;\n                                return (0,_prismic_configuration__WEBPACK_IMPORTED_MODULE_5__.Client)().getSingle(\"footer\");\n                            case 8:\n                                _ctx.t1 = _ctx.sent;\n                                if (_ctx.t1) {\n                                    _ctx.next = 11;\n                                    break;\n                                }\n                                _ctx.t1 = {\n                                };\n                            case 11:\n                                footer = _ctx.t1;\n                                return _ctx.abrupt(\"return\", {\n                                    props: {\n                                        menu: menu,\n                                        footer: footer\n                                    }\n                                });\n                            case 13:\n                            case \"end\":\n                                return _ctx.stop();\n                        }\n                    }, _callee);\n                }))();\n            }\n        }\n    ]);\n    return MyApp;\n}((next_app__WEBPACK_IMPORTED_MODULE_4___default()));\n\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUI7QUFDYztBQUNUO0FBQ21CO0FBRWxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVWSSxLQUFLLGlCQUFYLFFBQVE7O2NBQUZBLEtBQUs7YUFBTEEsS0FBSzs4QkFBTEEsS0FBSztnRUFBTEEsS0FBSzs7aUJBQUxBLEtBQUs7O1lBWXhCQyxHQUFNLEVBQU5BLENBQU07bUJBQU5BLFFBQVEsQ0FBUkEsTUFBTSxHQUFHLENBQUM7Z0JBQ1IsR0FBSyxDQUFtQyxNQUFVLEdBQVYsSUFBSSxDQUFDQyxLQUFLLEVBQTFDQyxTQUFTLEdBQXVCLE1BQVUsQ0FBMUNBLFNBQVMsRUFBRUMsU0FBUyxHQUFZLE1BQVUsQ0FBL0JBLFNBQVMsRUFBRUYsS0FBSyxHQUFLLE1BQVUsQ0FBcEJBLEtBQUs7Z0JBQ25DLE1BQU0sc0VBQ0hDLFNBQVM7bUJBQUtDLFNBQVM7b0JBQUVDLElBQUksRUFBRUgsS0FBSyxDQUFDRyxJQUFJO29CQUFFQyxNQUFNLEVBQUVKLEtBQUssQ0FBQ0ksTUFBTTs7Ozs7Ozs7WUFFcEUsQ0FBQzs7OztZQWhCWUMsR0FBZSxFQUFmQSxDQUFlO21CQUE1QixRQUFRLENBQUtBLGVBQWUsQ0FBQ0MsTUFBTTt3TUFBbkMsUUFBUSxXQUE2QixDQUFDO3dCQUM5QkgsSUFBSSxFQUNKQyxNQUFNOzs7Ozt1Q0FEUVAsOERBQU0sR0FBR1UsU0FBUyxDQUFDLENBQU07Ozs7Ozs7MENBQU0sQ0FBQztnQ0FBQSxDQUFDOztnQ0FBL0NKLElBQUk7O3VDQUNZTiw4REFBTSxHQUFHVSxTQUFTLENBQUMsQ0FBUTs7Ozs7OzswQ0FBTSxDQUFDO2dDQUFBLENBQUM7O2dDQUFuREgsTUFBTTs2REFDTCxDQUFDO29DQUNOSixLQUFLLEVBQUUsQ0FBQzt3Q0FDTkcsSUFBSSxFQUFFQSxJQUFJO3dDQUNWQyxNQUFNLEVBQUVBLE1BQU07b0NBQ2hCLENBQUM7Z0NBQ0gsQ0FBQzs7Ozs7O2dCQUNILENBQUM7Ozs7V0FWa0JOLEtBQUs7RUFBU0YsaURBQU87QUFBaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC5qcz9lMGFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcmlzbWljIGZyb20gJ0BwcmlzbWljaW8vY2xpZW50J1xuaW1wb3J0IE5leHRBcHAgZnJvbSAnbmV4dC9hcHAnXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi4vcHJpc21pYy1jb25maWd1cmF0aW9uXCI7XG5cbmltcG9ydCBcIi4uL3N0eWxlcy9nbG9iYWxzLnNjc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlBcHAgZXh0ZW5kcyBOZXh0QXBwIHtcbiAgc3RhdGljIGFzeW5jIGdldEluaXRpYWxQcm9wcyhhcHBDdHgpIHtcbiAgICBjb25zdCBtZW51ID0gKGF3YWl0IENsaWVudCgpLmdldFNpbmdsZShcIm1lbnVcIikpIHx8IHt9O1xuICAgIGNvbnN0IGZvb3RlciA9IChhd2FpdCBDbGllbnQoKS5nZXRTaW5nbGUoXCJmb290ZXJcIikpIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBtZW51OiBtZW51LFxuICAgICAgICBmb290ZXI6IGZvb3RlclxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50LCBwYWdlUHJvcHMsIHByb3BzIH0gPSB0aGlzLnByb3BzXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gbWVudT17cHJvcHMubWVudX0gZm9vdGVyPXtwcm9wcy5mb290ZXJ9IC8+XG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJQcmlzbWljIiwiTmV4dEFwcCIsIkNsaWVudCIsIk15QXBwIiwicmVuZGVyIiwicHJvcHMiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJtZW51IiwiZm9vdGVyIiwiZ2V0SW5pdGlhbFByb3BzIiwiYXBwQ3R4IiwiZ2V0U2luZ2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.js\n");

/***/ }),

/***/ "./prismic-configuration.js":
/*!**********************************!*\
  !*** ./prismic-configuration.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"repoName\": function() { return /* binding */ repoName; },\n/* harmony export */   \"apiEndpoint\": function() { return /* binding */ apiEndpoint; },\n/* harmony export */   \"accessToken\": function() { return /* binding */ accessToken; },\n/* harmony export */   \"linkResolver\": function() { return /* binding */ linkResolver; },\n/* harmony export */   \"hrefResolver\": function() { return /* binding */ hrefResolver; },\n/* harmony export */   \"customLink\": function() { return /* binding */ customLink; },\n/* harmony export */   \"Router\": function() { return /* binding */ Router; },\n/* harmony export */   \"Client\": function() { return /* binding */ Client; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _prismicio_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prismicio/client */ \"./node_modules/@prismicio/client/esm/@prismicio/client.mjs\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\nvar _this = undefined;\n// -- Prismic Repo Name\nvar repoName = 'eyemove';\n// -- Prismic API endpoint\n// Determines which repository to query and fetch data from\n// Configure your site's access point here\nvar apiEndpoint = \"https://\".concat(repoName, \".prismic.io/api/v2\");\n// -- Access Token if the repository is not public\n// Generate a token in your dashboard and configure it here if your repository is private\nvar accessToken = 'MC5ZYW8wV0JNQUFDQUF6d3ls.77-9Tmnvv70GDO-_ve-_vX4P77-977-977-9TO-_vWfvv71V77-9R--_vT3vv70W77-977-9LHFPBe-_ve-_vQ';\n// -- Link resolution rules\n// Manages the url links to internal Prismic documents\nvar linkResolver = function(doc) {\n    if (doc.type === \"page\") {\n        return \"/\".concat(doc.uid);\n    }\n    if (doc.type === 'info') {\n        return \"/praktische-informatie\";\n    }\n    return \"/\";\n};\n// Additional helper function for Next/Link components\nvar hrefResolver = function(doc) {\n    if (doc.type === 'info') {\n        return '/praktische-informatie';\n    }\n    return '/';\n};\nvar customLink = function(type, element, content, children, index) {\n    /*#__PURE__*/ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n        href: linkResolver(element.data),\n        as: linkResolver(element.data),\n        __source: {\n            fileName: \"/Users/janinezielman/Documents/Sites/Prismic/eyemove/prismic-configuration.js\",\n            lineNumber: 38,\n            columnNumber: 3\n        },\n        __self: _this,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            __source: {\n                fileName: \"/Users/janinezielman/Documents/Sites/Prismic/eyemove/prismic-configuration.js\",\n                lineNumber: 43,\n                columnNumber: 5\n            },\n            __self: _this,\n            children: content\n        })\n    }, index);\n};\nvar Router = {\n    routes: [\n        {\n            \"type\": \"page\",\n            \"path\": \"/:uid\"\n        }\n    ],\n    href: function(type) {\n        var route = Router.routes.find(function(r) {\n            return r.type === type;\n        });\n        return route && route.href;\n    }\n};\nvar Client = function(param, param1) {\n    var req = param === void 0 ? null : param, options = param1 === void 0 ? {\n    } : param1;\n    return _prismicio_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"].client(apiEndpoint, Object.assign({\n        routes: Router.routes\n    }, options));\n};\n_c = Client;\nvar _c;\n$RefreshReg$(_c, \"Client\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wcmlzbWljLWNvbmZpZ3VyYXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ1g7O0FBRTVCLEVBQXVCO0FBQ2hCLEdBQUssQ0FBQ0UsUUFBUSxHQUFHLENBQVM7QUFFakMsRUFBMEI7QUFDMUIsRUFBMkQ7QUFDM0QsRUFBMEM7QUFDbkMsR0FBSyxDQUFDQyxXQUFXLEdBQUksQ0FBUSxVQUFXLE1BQWtCLENBQTNCRCxRQUFRLEVBQUMsQ0FBa0I7QUFFakUsRUFBa0Q7QUFDbEQsRUFBeUY7QUFDbEYsR0FBSyxDQUFDRSxXQUFXLEdBQUcsQ0FBaUg7QUFHNUksRUFBMkI7QUFDM0IsRUFBc0Q7QUFDL0MsR0FBSyxDQUFDQyxZQUFZLEdBQUcsUUFBUSxDQUFQQyxHQUFHLEVBQUssQ0FBQztJQUNwQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQ0MsSUFBSSxLQUFLLENBQU0sT0FBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBRSxDQUFDLEdBQVUsT0FBUkQsR0FBRyxDQUFDRSxHQUFHO0lBQ3BCLENBQUM7SUFDRCxFQUFFLEVBQUVGLEdBQUcsQ0FBQ0MsSUFBSSxLQUFLLENBQU0sT0FBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBRSxDQUFzQjtJQUNoQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUc7QUFDWixDQUFDO0FBRUQsRUFBc0Q7QUFDL0MsR0FBSyxDQUFDRSxZQUFZLEdBQUcsUUFBUSxDQUFQSCxHQUFHLEVBQUssQ0FBQztJQUNwQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQ0MsSUFBSSxLQUFLLENBQU0sT0FBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxDQUF3QjtJQUNqQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUc7QUFDWixDQUFDO0FBRU0sR0FBSyxDQUFDRyxVQUFVLEdBQUcsUUFBUSxDQUFQSCxJQUFJLEVBQUVJLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEtBQUs7a0JBQ2hFLE1BQ0YsQ0FBQyx1REFERWIsa0RBQUk7UUFFSGMsSUFBSSxFQUFFVixZQUFZLENBQUNNLE9BQU8sQ0FBQ0ssSUFBSTtRQUMvQkMsRUFBRSxFQUFFWixZQUFZLENBQUNNLE9BQU8sQ0FBQ0ssSUFBSTs7Ozs7Ozt1RkFFNUJFLENBQUM7Ozs7Ozs7c0JBQUVOLE9BQU87O09BSk5FLEtBQUs7O0FBUVAsR0FBSyxDQUFDSyxNQUFNLEdBQUcsQ0FBQztJQUNyQkMsTUFBTSxFQUFFLENBQUM7UUFBQSxDQUFDO1lBQUEsQ0FBTSxPQUFDLENBQU07WUFBQyxDQUFNLE9BQUMsQ0FBTztRQUFBLENBQUM7SUFBQSxDQUFDO0lBQ3hDTCxJQUFJLEVBQUUsUUFBUSxDQUFQUixJQUFJLEVBQUssQ0FBQztRQUNmLEdBQUssQ0FBQ2MsS0FBSyxHQUFHRixNQUFNLENBQUNDLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDQyxRQUFRLENBQVJBLENBQUM7WUFBSUEsTUFBTSxDQUFOQSxDQUFDLENBQUNoQixJQUFJLEtBQUtBLElBQUk7O1FBQ3JELE1BQU0sQ0FBQ2MsS0FBSyxJQUFJQSxLQUFLLENBQUNOLElBQUk7SUFDNUIsQ0FBQztBQUNILENBQUM7QUFFTSxHQUFLLENBQUNTLE1BQU0sR0FBRyxRQUFRO1FBQVBDLEdBQUcsc0JBQUcsSUFBSSxVQUFFQyxPQUFPLHVCQUFHLENBQUM7SUFBQSxDQUFDO0lBQUssTUFDaEQsQ0FBRjFCLGdFQUFjLENBQUNHLFdBQVcsRUFBRXlCLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLENBQUM7UUFBQ1QsTUFBTSxFQUFFRCxNQUFNLENBQUNDLE1BQU07SUFBQyxDQUFDLEVBQUVNLE9BQU87O0tBRGpFRixNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3ByaXNtaWMtY29uZmlndXJhdGlvbi5qcz84MTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcmlzbWljIGZyb20gXCJAcHJpc21pY2lvL2NsaWVudFwiO1xuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuXG4vLyAtLSBQcmlzbWljIFJlcG8gTmFtZVxuZXhwb3J0IGNvbnN0IHJlcG9OYW1lID0gJ2V5ZW1vdmUnXG5cbi8vIC0tIFByaXNtaWMgQVBJIGVuZHBvaW50XG4vLyBEZXRlcm1pbmVzIHdoaWNoIHJlcG9zaXRvcnkgdG8gcXVlcnkgYW5kIGZldGNoIGRhdGEgZnJvbVxuLy8gQ29uZmlndXJlIHlvdXIgc2l0ZSdzIGFjY2VzcyBwb2ludCBoZXJlXG5leHBvcnQgY29uc3QgYXBpRW5kcG9pbnQgPSBgaHR0cHM6Ly8ke3JlcG9OYW1lfS5wcmlzbWljLmlvL2FwaS92MmBcblxuLy8gLS0gQWNjZXNzIFRva2VuIGlmIHRoZSByZXBvc2l0b3J5IGlzIG5vdCBwdWJsaWNcbi8vIEdlbmVyYXRlIGEgdG9rZW4gaW4geW91ciBkYXNoYm9hcmQgYW5kIGNvbmZpZ3VyZSBpdCBoZXJlIGlmIHlvdXIgcmVwb3NpdG9yeSBpcyBwcml2YXRlXG5leHBvcnQgY29uc3QgYWNjZXNzVG9rZW4gPSAnTUM1WllXOHdWMEpOUVVGRFFVRjZkM2xzLjc3LTlUbW52djcwR0RPLV92ZS1fdlg0UDc3LTk3Ny05NzctOVRPLV92V2Z2djcxVjc3LTlSLS1fdlQzdnY3MFc3Ny05NzctOUxIRlBCZS1fdmUtX3ZRJ1xuXG5cbi8vIC0tIExpbmsgcmVzb2x1dGlvbiBydWxlc1xuLy8gTWFuYWdlcyB0aGUgdXJsIGxpbmtzIHRvIGludGVybmFsIFByaXNtaWMgZG9jdW1lbnRzXG5leHBvcnQgY29uc3QgbGlua1Jlc29sdmVyID0gKGRvYykgPT4ge1xuICBpZiAoZG9jLnR5cGUgPT09IFwicGFnZVwiKSB7XG4gICAgcmV0dXJuIGAvJHtkb2MudWlkfWA7XG4gIH1cbiAgaWYgKGRvYy50eXBlID09PSAnaW5mbycpIHtcbiAgICByZXR1cm4gYC9wcmFrdGlzY2hlLWluZm9ybWF0aWVgXG4gIH1cbiAgcmV0dXJuIFwiL1wiO1xufTtcblxuLy8gQWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIE5leHQvTGluayBjb21wb25lbnRzXG5leHBvcnQgY29uc3QgaHJlZlJlc29sdmVyID0gKGRvYykgPT4ge1xuICBpZiAoZG9jLnR5cGUgPT09ICdpbmZvJykge1xuICAgIHJldHVybiAnL3ByYWt0aXNjaGUtaW5mb3JtYXRpZSdcbiAgfVxuICByZXR1cm4gJy8nXG59XG5cbmV4cG9ydCBjb25zdCBjdXN0b21MaW5rID0gKHR5cGUsIGVsZW1lbnQsIGNvbnRlbnQsIGNoaWxkcmVuLCBpbmRleCkgPT4gKFxuICA8TGlua1xuICAgIGtleT17aW5kZXh9XG4gICAgaHJlZj17bGlua1Jlc29sdmVyKGVsZW1lbnQuZGF0YSl9XG4gICAgYXM9e2xpbmtSZXNvbHZlcihlbGVtZW50LmRhdGEpfVxuICA+XG4gICAgPGE+e2NvbnRlbnR9PC9hPlxuICA8L0xpbms+XG4pO1xuXG5leHBvcnQgY29uc3QgUm91dGVyID0ge1xuICByb3V0ZXM6IFt7XCJ0eXBlXCI6XCJwYWdlXCIsXCJwYXRoXCI6XCIvOnVpZFwifV0sXG4gIGhyZWY6ICh0eXBlKSA9PiB7XG4gICAgY29uc3Qgcm91dGUgPSBSb3V0ZXIucm91dGVzLmZpbmQociA9PiByLnR5cGUgPT09IHR5cGUpO1xuICAgIHJldHVybiByb3V0ZSAmJiByb3V0ZS5ocmVmO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgQ2xpZW50ID0gKHJlcSA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKFxuICBQcmlzbWljLmNsaWVudChhcGlFbmRwb2ludCwgT2JqZWN0LmFzc2lnbih7IHJvdXRlczogUm91dGVyLnJvdXRlcyB9LCBvcHRpb25zKSlcbik7XG4iXSwibmFtZXMiOlsiUHJpc21pYyIsIkxpbmsiLCJyZXBvTmFtZSIsImFwaUVuZHBvaW50IiwiYWNjZXNzVG9rZW4iLCJsaW5rUmVzb2x2ZXIiLCJkb2MiLCJ0eXBlIiwidWlkIiwiaHJlZlJlc29sdmVyIiwiY3VzdG9tTGluayIsImVsZW1lbnQiLCJjb250ZW50IiwiY2hpbGRyZW4iLCJpbmRleCIsImhyZWYiLCJkYXRhIiwiYXMiLCJhIiwiUm91dGVyIiwicm91dGVzIiwicm91dGUiLCJmaW5kIiwiciIsIkNsaWVudCIsInJlcSIsIm9wdGlvbnMiLCJjbGllbnQiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./prismic-configuration.js\n");

/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ (function(module, exports) {

eval("var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RDs7QUFFQSxDQUFDLEdBQUc7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFlO0FBQ2YsYUFBYSxtQ0FBbUMsT0FBTztBQUN2RCxlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3Jvc3MtZmV0Y2gvZGlzdC9icm93c2VyLXBvbnlmaWxsLmpzP2ViZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzO1xudmFyIF9fc2VsZl9fID0gKGZ1bmN0aW9uICgpIHtcbmZ1bmN0aW9uIEYoKSB7XG50aGlzLmZldGNoID0gZmFsc2U7XG50aGlzLkRPTUV4Y2VwdGlvbiA9IGdsb2JhbC5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gZ2xvYmFsO1xucmV0dXJuIG5ldyBGKCk7XG59KSgpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxudmFyIGlycmVsZXZhbnQgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgICAnQmxvYicgaW4gc2VsZiAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keTtcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKTtcbiAgICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghc2VsZi5mZXRjaCkge1xuICAgIHNlbGYuZmV0Y2ggPSBmZXRjaDtcbiAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSkpO1xufSkoX19zZWxmX18pO1xuX19zZWxmX18uZmV0Y2gucG9ueWZpbGwgPSB0cnVlO1xuLy8gUmVtb3ZlIFwicG9seWZpbGxcIiBwcm9wZXJ0eSBhZGRlZCBieSB3aGF0d2ctZmV0Y2hcbmRlbGV0ZSBfX3NlbGZfXy5mZXRjaC5wb2x5ZmlsbDtcbi8vIENob29zZSBiZXR3ZWVuIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiAoZ2xvYmFsKSBvciBjdXN0b20gaW1wbGVtZW50YXRpb24gKF9fc2VsZl9fKVxuLy8gdmFyIGN0eCA9IGdsb2JhbC5mZXRjaCA/IGdsb2JhbCA6IF9fc2VsZl9fO1xudmFyIGN0eCA9IF9fc2VsZl9fOyAvLyB0aGlzIGxpbmUgZGlzYWJsZSBzZXJ2aWNlIHdvcmtlciBzdXBwb3J0IHRlbXBvcmFyaWx5XG5leHBvcnRzID0gY3R4LmZldGNoIC8vIFRvIGVuYWJsZTogaW1wb3J0IGZldGNoIGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5kZWZhdWx0ID0gY3R4LmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQge2ZldGNofSBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuSGVhZGVycyA9IGN0eC5IZWFkZXJzXG5leHBvcnRzLlJlcXVlc3QgPSBjdHguUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IGN0eC5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cross-fetch/dist/browser-ponyfill.js\n");

/***/ }),

/***/ "./node_modules/next/app.js":
/*!**********************************!*\
  !*** ./node_modules/next/app.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/pages/_app */ \"./node_modules/next/dist/pages/_app.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9hcHAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsdUdBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2FwcC5qcz82NmVjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3BhZ2VzL19hcHAnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/app.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"html,\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  font-family: \\\"Avenir Roman\\\";\\n  max-width: 100vw;\\n  overflow-x: hidden;\\n}\\n\\n* {\\n  box-sizing: border-box;\\n}\\n\\nh1 {\\n  font-size: 36px;\\n  margin: 0;\\n}\\n\\nh3 {\\n  font-size: 24px;\\n}\\n\\np {\\n  font-size: 18px;\\n  line-height: 1.4;\\n}\\n\\na {\\n  color: inherit;\\n}\\na:hover {\\n  color: #095463;\\n}\\n\\nimg {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n.container {\\n  max-width: 1200px;\\n  margin: auto;\\n  padding: 24px 0px;\\n}\\n\\n.page {\\n  margin-top: 100px;\\n}\\n\\n.home .two-columns:nth-child(odd) {\\n  background-color: #B8F2F7;\\n}\\n.home .container {\\n  padding: 90px 0;\\n}\\n\\nheader {\\n  position: fixed;\\n  z-index: 999;\\n  top: 0;\\n  width: 100%;\\n  display: flex;\\n  justify-content: space-between;\\n  padding: 8px 20px;\\n  align-items: center;\\n  background-color: #B8F2F7;\\n}\\nheader nav ul {\\n  justify-content: flex-end;\\n}\\nheader .logo img {\\n  width: 55px;\\n  height: auto;\\n}\\n\\nnav ul {\\n  list-style: none;\\n  display: flex;\\n}\\nnav ul li {\\n  margin: 0 20px;\\n  font-size: 20px;\\n}\\nnav ul li a {\\n  text-decoration: none;\\n}\\n\\nfooter {\\n  background-color: #B8F2F7;\\n  padding: 14px;\\n}\\nfooter .columns {\\n  display: flex;\\n}\\nfooter .columns .column {\\n  padding: 20px;\\n  width: 33%;\\n}\\nfooter nav ul {\\n  justify-content: center;\\n}\\n\\n.hero {\\n  width: 100vw;\\n  height: 100vh;\\n  display: flex;\\n}\\n\\n.hero-img {\\n  width: 100vw;\\n  height: 100vh;\\n  opacity: 0.65;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  z-index: -1;\\n}\\n\\n.hero-txt {\\n  width: 950px;\\n  margin: auto auto;\\n  padding: 20px;\\n  border: 1px solid black;\\n  line-height: 1.5;\\n  text-align: center;\\n  opacity: 1;\\n}\\n\\n.two-columns .container {\\n  display: flex;\\n}\\n.two-columns .column {\\n  width: 50%;\\n}\\n.two-columns .column ul {\\n  font-size: 24px;\\n}\\n\\n.text-block {\\n  max-width: 900px;\\n  margin: auto;\\n}\\n\\ntable {\\n  width: 100%;\\n  border-spacing: 0px;\\n  text-align: center;\\n}\\ntable tr td {\\n  padding: 10px;\\n  border-bottom: 1px solid black;\\n  border-right: 1px solid black;\\n}\\ntable tr td:nth-child(1) {\\n  border-left: 1px solid black;\\n}\\ntable tr:nth-child(1) {\\n  background-color: #B8F2F7;\\n}\\ntable tr:nth-child(1) td {\\n  padding: 10px;\\n  border-top: 1px solid black;\\n}\\n\\n.mapouter {\\n  position: relative;\\n  text-align: right;\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n.gmap_canvas {\\n  overflow: hidden;\\n  background: none !important;\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n.contact {\\n  padding: 48px 20px;\\n  text-align: center;\\n}\\n.contact .columns {\\n  margin-top: 48px;\\n  display: flex;\\n}\\n.contact .columns .column {\\n  width: 50%;\\n  padding: 10px;\\n  text-align: left;\\n}\\n.contact .columns .column form {\\n  width: 95%;\\n  display: block;\\n  margin: auto;\\n}\\n.contact .columns .column form label, .contact .columns .column form input, .contact .columns .column form textarea {\\n  width: 100%;\\n}\\n.contact .columns .column form input {\\n  margin: 10px 0 20px 0;\\n  padding: 14px;\\n}\\n.contact .columns .column form input[type=submit] {\\n  background-color: #095463;\\n  color: #fff;\\n  font-size: 18px;\\n  border: none;\\n  cursor: pointer;\\n}\\n\\n@media screen and (max-width: 950px) {\\n  h1 {\\n    font-size: 28px;\\n  }\\n\\n  h3 {\\n    font-size: 20px;\\n  }\\n\\n  p {\\n    font-size: 16px;\\n    line-height: 1.4;\\n  }\\n\\n  .page {\\n    margin-top: 80px;\\n    padding: 10px;\\n  }\\n\\n  .hero-txt {\\n    width: 95%;\\n    margin: auto;\\n  }\\n  .hero-txt h1 {\\n    font-size: 22px;\\n  }\\n\\n  div.text-block {\\n    padding: 0 10px;\\n  }\\n\\n  .home .container {\\n    padding: 45px 0px;\\n  }\\n\\n  nav {\\n    width: 100%;\\n  }\\n  nav ul {\\n    margin: 0;\\n    padding: 0;\\n  }\\n  nav ul li {\\n    margin: 0 10px;\\n  }\\n  nav a {\\n    font-size: 16px;\\n  }\\n\\n  header {\\n    display: flex;\\n    padding: 10px 10px;\\n  }\\n  header .logo img {\\n    width: 50px;\\n  }\\n\\n  .container {\\n    display: block;\\n    margin: auto;\\n    width: 100%;\\n  }\\n  .container .column {\\n    width: 100%;\\n  }\\n\\n  .two-columns .container {\\n    display: block;\\n    margin: auto;\\n    width: 90%;\\n  }\\n  .two-columns .container .column {\\n    width: 100%;\\n  }\\n\\n  table {\\n    font-size: 0.9em;\\n  }\\n\\n  .contact .columns, footer .columns {\\n    display: block;\\n  }\\n  .contact .columns .column, footer .columns .column {\\n    width: 100%;\\n    margin-bottom: 14px;\\n    padding: 5px 10px;\\n  }\\n\\n  .contact {\\n    padding: 0;\\n  }\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://globals.scss\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"html,\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  font-family: 'Avenir Roman';\\n  max-width: 100vw;\\n  overflow-x: hidden;\\n}\\n\\n* {\\n  box-sizing: border-box;\\n}\\n\\nh1{\\n  font-size: 36px;\\n  margin: 0;\\n}\\n\\nh3{\\n  font-size: 24px;\\n}\\n\\np{\\n  font-size: 18px;\\n  line-height: 1.4;\\n}\\n\\na {\\n  color: inherit;\\n  &:hover{\\n    color: #095463;\\n  }\\n}\\n\\nimg{\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n.container{\\n  max-width: 1200px;\\n  margin: auto;\\n  padding: 24px 0px;\\n}\\n\\n.page{\\n  margin-top: 100px;\\n}\\n\\n.home{\\n  .two-columns:nth-child(odd){\\n    background-color: #B8F2F7;\\n  }\\n  .container{\\n    padding: 90px 0;\\n  }\\n}\\n\\nheader{\\n  position: fixed;\\n  z-index: 999;\\n  top: 0;\\n  width: 100%;\\n  display: flex;\\n  justify-content: space-between;\\n  padding: 8px 20px;\\n  align-items: center;\\n  background-color: #B8F2F7;\\n  nav{\\n    ul{\\n      justify-content: flex-end;\\n    }\\n  }\\n  .logo{\\n    img{\\n      width: 55px;\\n      height: auto;\\n    }\\n  }\\n}\\n\\nnav{\\n  ul{\\n    list-style: none;\\n    display: flex;\\n    li{\\n      margin: 0 20px;\\n      font-size: 20px;\\n      a{\\n        text-decoration: none;\\n      }\\n    }\\n  }\\n}\\n\\nfooter{\\n  background-color: #B8F2F7;\\n  padding: 14px;\\n  .columns{\\n    display: flex;\\n    .column{\\n      padding: 20px;\\n      width: 33%;\\n    }\\n  }\\n  nav{\\n    ul{\\n      justify-content: center;\\n    }\\n  }\\n}\\n\\n.hero{\\n  width: 100vw;\\n  height: 100vh;\\n  display: flex;\\n}\\n\\n.hero-img{\\n  width: 100vw;\\n  height: 100vh;\\n  opacity: 0.65;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  z-index: -1;\\n}\\n\\n.hero-txt{\\n  width: 950px;\\n  margin: auto auto;\\n  padding: 20px;\\n  border: 1px solid black;\\n  line-height: 1.5;\\n  text-align: center;\\n  opacity: 1;\\n}\\n\\n\\n.two-columns{\\n  .container{\\n    display: flex;\\n  }\\n  .column{\\n    width: 50%;\\n    ul{\\n      font-size: 24px;\\n    }\\n  }\\n}\\n\\n.text-block{\\n  max-width: 900px;\\n  margin: auto;\\n}\\n\\ntable{\\n  width: 100%;\\n  border-spacing: 0px;\\n  text-align: center;\\n  tr{\\n    td{\\n      &:nth-child(1){\\n        border-left: 1px solid black;\\n      }\\n      padding: 10px;\\n      border-bottom: 1px solid black;\\n      border-right: 1px solid black;\\n    }\\n    &:nth-child(1){\\n      background-color: #B8F2F7;\\n      td{\\n        padding: 10px;\\n        border-top: 1px solid black;\\n      }\\n    }\\n  }\\n}\\n\\n.mapouter{position:relative;text-align:right;height:100%;width:100%;}\\n.gmap_canvas {overflow:hidden;background:none!important;height:100%;width:100%;}\\n\\n.contact{\\n  padding: 48px 20px;\\n  text-align: center;\\n  .columns{\\n    margin-top: 48px;\\n    display: flex;\\n    .column{\\n      width: 50%;\\n      padding: 10px;\\n      text-align: left;\\n      form{\\n        width: 95%;\\n        display: block;\\n        margin: auto;\\n        label, input, textarea{\\n          width: 100%;\\n        }\\n        input{\\n          margin: 10px 0 20px 0;\\n          padding: 14px;\\n          &[type=submit]{\\n            background-color: #095463;\\n            color: #fff;\\n            font-size: 18px;\\n            border: none;\\n            cursor: pointer;\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n@media screen and (max-width: 950px) {\\n  h1{\\n    font-size: 28px;\\n  }\\n  \\n  h3{\\n    font-size: 20px;\\n  }\\n  \\n  p{\\n    font-size: 16px;\\n    line-height: 1.4;\\n  }\\n  .page{\\n    margin-top: 80px;\\n    padding: 10px;\\n  }\\n  .hero-txt{\\n    width: 95%;\\n    margin: auto;\\n    h1{\\n      font-size: 22px;\\n    }\\n  }\\n  div.text-block{\\n    padding: 0 10px;\\n  }\\n  .home .container{\\n    padding: 45px 0px;\\n  }\\n  nav{\\n    width: 100%;\\n    ul{\\n      margin: 0;\\n      padding: 0;\\n      li{\\n        margin: 0 10px;\\n      }\\n    }\\n    a{\\n      font-size: 16px;\\n    }\\n  }\\n  header{\\n    display: flex;\\n    padding: 10px 10px;\\n    .logo{\\n      img{\\n        width: 50px;\\n      }\\n    }\\n  }\\n  .container{\\n    display: block;\\n    margin: auto;\\n    width: 100%;\\n    .column{\\n      width: 100%;\\n    }\\n  }  \\n  .two-columns{\\n    .container{\\n      display: block;\\n      margin: auto;\\n      width: 90%;\\n      .column{\\n        width: 100%;\\n      }\\n    }  \\n  }\\n  table{\\n    font-size: 0.9em;\\n  }\\n  .contact, footer{\\n    .columns{\\n      display: block;\\n      .column{\\n        width: 100%;\\n        margin-bottom: 14px;\\n        padding: 5px 10px;\\n      }\\n    }\\n  }\\n  .contact{\\n    padding: 0;\\n  }\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzEwXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzNdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbMTBdLnVzZVs0XSEuL3N0eWxlcy9nbG9iYWxzLnNjc3MuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDd0g7QUFDeEgsOEJBQThCLGtIQUEyQjtBQUN6RDtBQUNBLHVEQUF1RCxlQUFlLGNBQWMsa0NBQWtDLHFCQUFxQix1QkFBdUIsR0FBRyxPQUFPLDJCQUEyQixHQUFHLFFBQVEsb0JBQW9CLGNBQWMsR0FBRyxRQUFRLG9CQUFvQixHQUFHLE9BQU8sb0JBQW9CLHFCQUFxQixHQUFHLE9BQU8sbUJBQW1CLEdBQUcsV0FBVyxtQkFBbUIsR0FBRyxTQUFTLG9CQUFvQixpQkFBaUIsR0FBRyxnQkFBZ0Isc0JBQXNCLGlCQUFpQixzQkFBc0IsR0FBRyxXQUFXLHNCQUFzQixHQUFHLHVDQUF1Qyw4QkFBOEIsR0FBRyxvQkFBb0Isb0JBQW9CLEdBQUcsWUFBWSxvQkFBb0IsaUJBQWlCLFdBQVcsZ0JBQWdCLGtCQUFrQixtQ0FBbUMsc0JBQXNCLHdCQUF3Qiw4QkFBOEIsR0FBRyxpQkFBaUIsOEJBQThCLEdBQUcsb0JBQW9CLGdCQUFnQixpQkFBaUIsR0FB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QUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sV0FBVyxZQUFZLFdBQVcsVUFBVSxPQUFPLEtBQUssV0FBVyxZQUFZLFdBQVcsVUFBVSxPQUFPLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxVQUFVLEtBQUssS0FBSyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sS0FBSyxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsS0FBSyxzQ0FBc0MsZUFBZSxjQUFjLGdDQUFnQyxxQkFBcUIsdUJBQXVCLEdBQUcsT0FBTywyQkFBMkIsR0FBRyxPQUFPLG9CQUFvQixjQUFjLEdBQUcsT0FBTyxvQkFBb0IsR0FBRyxNQUFNLG9CQUFvQixxQkFBcUIsR0FBRyxPQUFPLG1CQUFtQixZQUFZLHFCQUFxQixLQUFLLEdBQUcsUUFBUSxvQkFBb0IsaUJBQWlCLEdBQUcsZUFBZSxzQkFBc0IsaUJBQWlCLHNCQUFzQixHQUFHLFVBQVUsc0JBQXNCLEdBQUcsVUFBVSxnQ0FBZ0MsZ0NBQWdDLEtBQUssZUFBZSxzQkFBc0IsS0FBSyxHQUFHLFdBQVcsb0JBQW9CLGlCQUFpQixXQUFXLGdCQUFnQixrQkFBa0IsbUNBQW1DLHNCQUFzQix3QkFBd0IsOEJBQThCLFFBQVEsU0FBUyxrQ0FBa0MsT0FBTyxLQUFLLFVBQVUsVUFBVSxvQkFBb0IscUJBQXFCLE9BQU8sS0FBSyxHQUFHLFFBQVEsT0FBTyx1QkFBdUIsb0JBQW9CLFNBQVMsdUJBQXVCLHdCQUF3QixVQUFVLGdDQUFnQyxTQUFTLE9BQU8sS0FBSyxHQUFHLFdBQVcsOEJBQThCLGtCQUFrQixhQUFhLG9CQUFvQixjQUFjLHNCQUFzQixtQkFBbUIsT0FBTyxLQUFLLFFBQVEsU0FBUyxnQ0FBZ0MsT0FBTyxLQUFLLEdBQUcsVUFBVSxpQkFBaUIsa0JBQWtCLGtCQUFrQixHQUFHLGNBQWMsaUJBQWlCLGtCQUFrQixrQkFBa0IsdUJBQXVCLFdBQVcsWUFBWSxnQkFBZ0IsR0FBRyxjQUFjLGlCQUFpQixzQkFBc0Isa0JBQWtCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGVBQWUsR0FBRyxtQkFBbUIsZUFBZSxvQkFBb0IsS0FBSyxZQUFZLGlCQUFpQixTQUFTLHdCQUF3QixPQUFPLEtBQUssR0FBRyxnQkFBZ0IscUJBQXFCLGlCQUFpQixHQUFHLFVBQVUsZ0JBQWdCLHdCQUF3Qix1QkFBdUIsT0FBTyxTQUFTLHVCQUF1Qix1Q0FBdUMsU0FBUyxzQkFBc0IsdUNBQXVDLHNDQUFzQyxPQUFPLHFCQUFxQixrQ0FBa0MsV0FBVyx3QkFBd0Isc0NBQXNDLFNBQVMsT0FBTyxLQUFLLEdBQUcsY0FBYyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxnQkFBZ0IsZ0JBQWdCLDBCQUEwQixZQUFZLFlBQVksYUFBYSx1QkFBdUIsdUJBQXVCLGFBQWEsdUJBQXVCLG9CQUFvQixjQUFjLG1CQUFtQixzQkFBc0IseUJBQXlCLGFBQWEscUJBQXFCLHlCQUF5Qix1QkFBdUIsaUNBQWlDLHdCQUF3QixXQUFXLGdCQUFnQixrQ0FBa0MsMEJBQTBCLDJCQUEyQix3Q0FBd0MsMEJBQTBCLDhCQUE4QiwyQkFBMkIsOEJBQThCLGFBQWEsV0FBVyxTQUFTLE9BQU8sS0FBSyxHQUFHLDBDQUEwQyxPQUFPLHNCQUFzQixLQUFLLFdBQVcsc0JBQXNCLEtBQUssVUFBVSxzQkFBc0IsdUJBQXVCLEtBQUssVUFBVSx1QkFBdUIsb0JBQW9CLEtBQUssY0FBYyxpQkFBaUIsbUJBQW1CLFNBQVMsd0JBQXdCLE9BQU8sS0FBSyxtQkFBbUIsc0JBQXNCLEtBQUsscUJBQXFCLHdCQUF3QixLQUFLLFFBQVEsa0JBQWtCLFNBQVMsa0JBQWtCLG1CQUFtQixXQUFXLHlCQUF5QixTQUFTLE9BQU8sUUFBUSx3QkFBd0IsT0FBTyxLQUFLLFdBQVcsb0JBQW9CLHlCQUF5QixZQUFZLFlBQVksc0JBQXNCLFNBQVMsT0FBTyxLQUFLLGVBQWUscUJBQXFCLG1CQUFtQixrQkFBa0IsY0FBYyxvQkFBb0IsT0FBTyxPQUFPLGlCQUFpQixpQkFBaUIsdUJBQXVCLHFCQUFxQixtQkFBbUIsZ0JBQWdCLHNCQUFzQixTQUFTLFNBQVMsS0FBSyxVQUFVLHVCQUF1QixLQUFLLHFCQUFxQixlQUFlLHVCQUF1QixnQkFBZ0Isc0JBQXNCLDhCQUE4Qiw0QkFBNEIsU0FBUyxPQUFPLEtBQUssYUFBYSxpQkFBaUIsS0FBSyxHQUFHLG1CQUFtQjtBQUNwMFY7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvZ2xvYmFscy5zY3NzP2E2ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsXFxuYm9keSB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJBdmVuaXIgUm9tYW5cXFwiO1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuKiB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDM2cHg7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogMjRweDtcXG59XFxuXFxucCB7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBsaW5lLWhlaWdodDogMS40O1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5hOmhvdmVyIHtcXG4gIGNvbG9yOiAjMDk1NDYzO1xcbn1cXG5cXG5pbWcge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4uY29udGFpbmVyIHtcXG4gIG1heC13aWR0aDogMTIwMHB4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgcGFkZGluZzogMjRweCAwcHg7XFxufVxcblxcbi5wYWdlIHtcXG4gIG1hcmdpbi10b3A6IDEwMHB4O1xcbn1cXG5cXG4uaG9tZSAudHdvLWNvbHVtbnM6bnRoLWNoaWxkKG9kZCkge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI0I4RjJGNztcXG59XFxuLmhvbWUgLmNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiA5MHB4IDA7XFxufVxcblxcbmhlYWRlciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBwYWRkaW5nOiA4cHggMjBweDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbn1cXG5oZWFkZXIgbmF2IHVsIHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxufVxcbmhlYWRlciAubG9nbyBpbWcge1xcbiAgd2lkdGg6IDU1cHg7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbm5hdiB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxubmF2IHVsIGxpIHtcXG4gIG1hcmdpbjogMCAyMHB4O1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbn1cXG5uYXYgdWwgbGkgYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbmZvb3RlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbiAgcGFkZGluZzogMTRweDtcXG59XFxuZm9vdGVyIC5jb2x1bW5zIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbmZvb3RlciAuY29sdW1ucyAuY29sdW1uIHtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICB3aWR0aDogMzMlO1xcbn1cXG5mb290ZXIgbmF2IHVsIHtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uaGVybyB7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLmhlcm8taW1nIHtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBvcGFjaXR5OiAwLjY1O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uaGVyby10eHQge1xcbiAgd2lkdGg6IDk1MHB4O1xcbiAgbWFyZ2luOiBhdXRvIGF1dG87XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuLnR3by1jb2x1bW5zIC5jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLnR3by1jb2x1bW5zIC5jb2x1bW4ge1xcbiAgd2lkdGg6IDUwJTtcXG59XFxuLnR3by1jb2x1bW5zIC5jb2x1bW4gdWwge1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbn1cXG5cXG4udGV4dC1ibG9jayB7XFxuICBtYXgtd2lkdGg6IDkwMHB4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG50YWJsZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbnRhYmxlIHRyIHRkIHtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcXG59XFxudGFibGUgdHIgdGQ6bnRoLWNoaWxkKDEpIHtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgYmxhY2s7XFxufVxcbnRhYmxlIHRyOm50aC1jaGlsZCgxKSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbn1cXG50YWJsZSB0cjpudGgtY2hpbGQoMSkgdGQge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLm1hcG91dGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5nbWFwX2NhbnZhcyB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgYmFja2dyb3VuZDogbm9uZSAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5jb250YWN0IHtcXG4gIHBhZGRpbmc6IDQ4cHggMjBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmNvbnRhY3QgLmNvbHVtbnMge1xcbiAgbWFyZ2luLXRvcDogNDhweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbi5jb250YWN0IC5jb2x1bW5zIC5jb2x1bW4ge1xcbiAgd2lkdGg6IDUwJTtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG4uY29udGFjdCAuY29sdW1ucyAuY29sdW1uIGZvcm0ge1xcbiAgd2lkdGg6IDk1JTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG4uY29udGFjdCAuY29sdW1ucyAuY29sdW1uIGZvcm0gbGFiZWwsIC5jb250YWN0IC5jb2x1bW5zIC5jb2x1bW4gZm9ybSBpbnB1dCwgLmNvbnRhY3QgLmNvbHVtbnMgLmNvbHVtbiBmb3JtIHRleHRhcmVhIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4uY29udGFjdCAuY29sdW1ucyAuY29sdW1uIGZvcm0gaW5wdXQge1xcbiAgbWFyZ2luOiAxMHB4IDAgMjBweCAwO1xcbiAgcGFkZGluZzogMTRweDtcXG59XFxuLmNvbnRhY3QgLmNvbHVtbnMgLmNvbHVtbiBmb3JtIGlucHV0W3R5cGU9c3VibWl0XSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDk1NDYzO1xcbiAgY29sb3I6ICNmZmY7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk1MHB4KSB7XFxuICBoMSB7XFxuICAgIGZvbnQtc2l6ZTogMjhweDtcXG4gIH1cXG5cXG4gIGgzIHtcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcbiAgfVxcblxcbiAgcCB7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG4gIH1cXG5cXG4gIC5wYWdlIHtcXG4gICAgbWFyZ2luLXRvcDogODBweDtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gIH1cXG5cXG4gIC5oZXJvLXR4dCB7XFxuICAgIHdpZHRoOiA5NSU7XFxuICAgIG1hcmdpbjogYXV0bztcXG4gIH1cXG4gIC5oZXJvLXR4dCBoMSB7XFxuICAgIGZvbnQtc2l6ZTogMjJweDtcXG4gIH1cXG5cXG4gIGRpdi50ZXh0LWJsb2NrIHtcXG4gICAgcGFkZGluZzogMCAxMHB4O1xcbiAgfVxcblxcbiAgLmhvbWUgLmNvbnRhaW5lciB7XFxuICAgIHBhZGRpbmc6IDQ1cHggMHB4O1xcbiAgfVxcblxcbiAgbmF2IHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuICBuYXYgdWwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuICBuYXYgdWwgbGkge1xcbiAgICBtYXJnaW46IDAgMTBweDtcXG4gIH1cXG4gIG5hdiBhIHtcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcbiAgfVxcblxcbiAgaGVhZGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgcGFkZGluZzogMTBweCAxMHB4O1xcbiAgfVxcbiAgaGVhZGVyIC5sb2dvIGltZyB7XFxuICAgIHdpZHRoOiA1MHB4O1xcbiAgfVxcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcbiAgLmNvbnRhaW5lciAuY29sdW1uIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuXFxuICAudHdvLWNvbHVtbnMgLmNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIHdpZHRoOiA5MCU7XFxuICB9XFxuICAudHdvLWNvbHVtbnMgLmNvbnRhaW5lciAuY29sdW1uIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuXFxuICB0YWJsZSB7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxuICB9XFxuXFxuICAuY29udGFjdCAuY29sdW1ucywgZm9vdGVyIC5jb2x1bW5zIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAuY29udGFjdCAuY29sdW1ucyAuY29sdW1uLCBmb290ZXIgLmNvbHVtbnMgLmNvbHVtbiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxNHB4O1xcbiAgICBwYWRkaW5nOiA1cHggMTBweDtcXG4gIH1cXG5cXG4gIC5jb250YWN0IHtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2dsb2JhbHMuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7RUFFRSxVQUFBO0VBQ0EsU0FBQTtFQUNBLDJCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtBQUNGOztBQUVBO0VBQ0Usc0JBQUE7QUFDRjs7QUFFQTtFQUNFLGVBQUE7RUFDQSxTQUFBO0FBQ0Y7O0FBRUE7RUFDRSxlQUFBO0FBQ0Y7O0FBRUE7RUFDRSxlQUFBO0VBQ0EsZ0JBQUE7QUFDRjs7QUFFQTtFQUNFLGNBQUE7QUFDRjtBQUFFO0VBQ0UsY0FBQTtBQUVKOztBQUVBO0VBQ0UsZUFBQTtFQUNBLFlBQUE7QUFDRjs7QUFFQTtFQUNFLGlCQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0FBQ0Y7O0FBRUE7RUFDRSxpQkFBQTtBQUNGOztBQUdFO0VBQ0UseUJBQUE7QUFBSjtBQUVFO0VBQ0UsZUFBQTtBQUFKOztBQUlBO0VBQ0UsZUFBQTtFQUNBLFlBQUE7RUFDQSxNQUFBO0VBQ0EsV0FBQTtFQUNBLGFBQUE7RUFDQSw4QkFBQTtFQUNBLGlCQUFBO0VBQ0EsbUJBQUE7RUFDQSx5QkFBQTtBQURGO0FBR0k7RUFDRSx5QkFBQTtBQUROO0FBS0k7RUFDRSxXQUFBO0VBQ0EsWUFBQTtBQUhOOztBQVNFO0VBQ0UsZ0JBQUE7RUFDQSxhQUFBO0FBTko7QUFPSTtFQUNFLGNBQUE7RUFDQSxlQUFBO0FBTE47QUFNTTtFQUNFLHFCQUFBO0FBSlI7O0FBVUE7RUFDRSx5QkFBQTtFQUNBLGFBQUE7QUFQRjtBQVFFO0VBQ0UsYUFBQTtBQU5KO0FBT0k7RUFDRSxhQUFBO0VBQ0EsVUFBQTtBQUxOO0FBU0k7RUFDRSx1QkFBQTtBQVBOOztBQVlBO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSxhQUFBO0FBVEY7O0FBWUE7RUFDRSxZQUFBO0VBQ0EsYUFBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLE1BQUE7RUFDQSxPQUFBO0VBQ0EsV0FBQTtBQVRGOztBQVlBO0VBQ0UsWUFBQTtFQUNBLGlCQUFBO0VBQ0EsYUFBQTtFQUNBLHVCQUFBO0VBQ0EsZ0JBQUE7RUFDQSxrQkFBQTtFQUNBLFVBQUE7QUFURjs7QUFjRTtFQUNFLGFBQUE7QUFYSjtBQWFFO0VBQ0UsVUFBQTtBQVhKO0FBWUk7RUFDRSxlQUFBO0FBVk47O0FBZUE7RUFDRSxnQkFBQTtFQUNBLFlBQUE7QUFaRjs7QUFlQTtFQUNFLFdBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0FBWkY7QUFjSTtFQUlFLGFBQUE7RUFDQSw4QkFBQTtFQUNBLDZCQUFBO0FBZk47QUFVTTtFQUNFLDRCQUFBO0FBUlI7QUFjSTtFQUNFLHlCQUFBO0FBWk47QUFhTTtFQUNFLGFBQUE7RUFDQSwyQkFBQTtBQVhSOztBQWlCQTtFQUFVLGtCQUFBO0VBQWtCLGlCQUFBO0VBQWlCLFlBQUE7RUFBWSxXQUFBO0FBVnpEOztBQVdBO0VBQWMsZ0JBQUE7RUFBZ0IsMkJBQUE7RUFBMEIsWUFBQTtFQUFZLFdBQUE7QUFKcEU7O0FBTUE7RUFDRSxrQkFBQTtFQUNBLGtCQUFBO0FBSEY7QUFJRTtFQUNFLGdCQUFBO0VBQ0EsYUFBQTtBQUZKO0FBR0k7RUFDRSxVQUFBO0VBQ0EsYUFBQTtFQUNBLGdCQUFBO0FBRE47QUFFTTtFQUNFLFVBQUE7RUFDQSxjQUFBO0VBQ0EsWUFBQTtBQUFSO0FBQ1E7RUFDRSxXQUFBO0FBQ1Y7QUFDUTtFQUNFLHFCQUFBO0VBQ0EsYUFBQTtBQUNWO0FBQVU7RUFDRSx5QkFBQTtFQUNBLFdBQUE7RUFDQSxlQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7QUFFWjs7QUFNQTtFQUNFO0lBQ0UsZUFBQTtFQUhGOztFQU1BO0lBQ0UsZUFBQTtFQUhGOztFQU1BO0lBQ0UsZUFBQTtJQUNBLGdCQUFBO0VBSEY7O0VBS0E7SUFDRSxnQkFBQTtJQUNBLGFBQUE7RUFGRjs7RUFJQTtJQUNFLFVBQUE7SUFDQSxZQUFBO0VBREY7RUFFRTtJQUNFLGVBQUE7RUFBSjs7RUFHQTtJQUNFLGVBQUE7RUFBRjs7RUFFQTtJQUNFLGlCQUFBO0VBQ0Y7O0VBQ0E7SUFDRSxXQUFBO0VBRUY7RUFERTtJQUNFLFNBQUE7SUFDQSxVQUFBO0VBR0o7RUFGSTtJQUNFLGNBQUE7RUFJTjtFQURFO0lBQ0UsZUFBQTtFQUdKOztFQUFBO0lBQ0UsYUFBQTtJQUNBLGtCQUFBO0VBR0Y7RUFESTtJQUNFLFdBQUE7RUFHTjs7RUFDQTtJQUNFLGNBQUE7SUFDQSxZQUFBO0lBQ0EsV0FBQTtFQUVGO0VBREU7SUFDRSxXQUFBO0VBR0o7O0VBQ0U7SUFDRSxjQUFBO0lBQ0EsWUFBQTtJQUNBLFVBQUE7RUFFSjtFQURJO0lBQ0UsV0FBQTtFQUdOOztFQUNBO0lBQ0UsZ0JBQUE7RUFFRjs7RUFDRTtJQUNFLGNBQUE7RUFFSjtFQURJO0lBQ0UsV0FBQTtJQUNBLG1CQUFBO0lBQ0EsaUJBQUE7RUFHTjs7RUFDQTtJQUNFLFVBQUE7RUFFRjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImh0bWwsXFxuYm9keSB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1mYW1pbHk6ICdBdmVuaXIgUm9tYW4nO1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuKiB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG5oMXtcXG4gIGZvbnQtc2l6ZTogMzZweDtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuaDN7XFxuICBmb250LXNpemU6IDI0cHg7XFxufVxcblxcbnB7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBsaW5lLWhlaWdodDogMS40O1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgJjpob3ZlcntcXG4gICAgY29sb3I6ICMwOTU0NjM7XFxuICB9XFxufVxcblxcbmltZ3tcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLmNvbnRhaW5lcntcXG4gIG1heC13aWR0aDogMTIwMHB4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgcGFkZGluZzogMjRweCAwcHg7XFxufVxcblxcbi5wYWdle1xcbiAgbWFyZ2luLXRvcDogMTAwcHg7XFxufVxcblxcbi5ob21le1xcbiAgLnR3by1jb2x1bW5zOm50aC1jaGlsZChvZGQpe1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbiAgfVxcbiAgLmNvbnRhaW5lcntcXG4gICAgcGFkZGluZzogOTBweCAwO1xcbiAgfVxcbn1cXG5cXG5oZWFkZXJ7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBwYWRkaW5nOiA4cHggMjBweDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbiAgbmF2e1xcbiAgICB1bHtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgICB9XFxuICB9XFxuICAubG9nb3tcXG4gICAgaW1ne1xcbiAgICAgIHdpZHRoOiA1NXB4O1xcbiAgICAgIGhlaWdodDogYXV0bztcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5uYXZ7XFxuICB1bHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgbGl7XFxuICAgICAgbWFyZ2luOiAwIDIwcHg7XFxuICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICAgIGF7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZvb3RlcntcXG4gIGJhY2tncm91bmQtY29sb3I6ICNCOEYyRjc7XFxuICBwYWRkaW5nOiAxNHB4O1xcbiAgLmNvbHVtbnN7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIC5jb2x1bW57XFxuICAgICAgcGFkZGluZzogMjBweDtcXG4gICAgICB3aWR0aDogMzMlO1xcbiAgICB9XFxuICB9XFxuICBuYXZ7XFxuICAgIHVse1xcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi5oZXJve1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5oZXJvLWltZ3tcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBvcGFjaXR5OiAwLjY1O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uaGVyby10eHR7XFxuICB3aWR0aDogOTUwcHg7XFxuICBtYXJnaW46IGF1dG8gYXV0bztcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG5cXG4udHdvLWNvbHVtbnN7XFxuICAuY29udGFpbmVye1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgfVxcbiAgLmNvbHVtbntcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgdWx7XFxuICAgICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICB9XFxuICB9XFxufVxcblxcbi50ZXh0LWJsb2Nre1xcbiAgbWF4LXdpZHRoOiA5MDBweDtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxuXFxudGFibGV7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB0cntcXG4gICAgdGR7XFxuICAgICAgJjpudGgtY2hpbGQoMSl7XFxuICAgICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkIGJsYWNrO1xcbiAgICAgIH1cXG4gICAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBibGFjaztcXG4gICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcXG4gICAgfVxcbiAgICAmOm50aC1jaGlsZCgxKXtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjhGMkY3O1xcbiAgICAgIHRke1xcbiAgICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLm1hcG91dGVye3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246cmlnaHQ7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt9XFxuLmdtYXBfY2FudmFzIHtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZDpub25lIWltcG9ydGFudDtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO31cXG5cXG4uY29udGFjdHtcXG4gIHBhZGRpbmc6IDQ4cHggMjBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIC5jb2x1bW5ze1xcbiAgICBtYXJnaW4tdG9wOiA0OHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAuY29sdW1ue1xcbiAgICAgIHdpZHRoOiA1MCU7XFxuICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgIGZvcm17XFxuICAgICAgICB3aWR0aDogOTUlO1xcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICBtYXJnaW46IGF1dG87XFxuICAgICAgICBsYWJlbCwgaW5wdXQsIHRleHRhcmVhe1xcbiAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlucHV0e1xcbiAgICAgICAgICBtYXJnaW46IDEwcHggMCAyMHB4IDA7XFxuICAgICAgICAgIHBhZGRpbmc6IDE0cHg7XFxuICAgICAgICAgICZbdHlwZT1zdWJtaXRde1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwOTU0NjM7XFxuICAgICAgICAgICAgY29sb3I6ICNmZmY7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogOTUwcHgpIHtcXG4gIGgxe1xcbiAgICBmb250LXNpemU6IDI4cHg7XFxuICB9XFxuICBcXG4gIGgze1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxuICB9XFxuICBcXG4gIHB7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG4gIH1cXG4gIC5wYWdle1xcbiAgICBtYXJnaW4tdG9wOiA4MHB4O1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgfVxcbiAgLmhlcm8tdHh0e1xcbiAgICB3aWR0aDogOTUlO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIGgxe1xcbiAgICAgIGZvbnQtc2l6ZTogMjJweDtcXG4gICAgfVxcbiAgfVxcbiAgZGl2LnRleHQtYmxvY2t7XFxuICAgIHBhZGRpbmc6IDAgMTBweDtcXG4gIH1cXG4gIC5ob21lIC5jb250YWluZXJ7XFxuICAgIHBhZGRpbmc6IDQ1cHggMHB4O1xcbiAgfVxcbiAgbmF2e1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgdWx7XFxuICAgICAgbWFyZ2luOiAwO1xcbiAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgbGl7XFxuICAgICAgICBtYXJnaW46IDAgMTBweDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgYXtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgIH1cXG4gIH1cXG4gIGhlYWRlcntcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgcGFkZGluZzogMTBweCAxMHB4O1xcbiAgICAubG9nb3tcXG4gICAgICBpbWd7XFxuICAgICAgICB3aWR0aDogNTBweDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC5jb250YWluZXJ7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAuY29sdW1ue1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICB9XFxuICB9ICBcXG4gIC50d28tY29sdW1uc3tcXG4gICAgLmNvbnRhaW5lcntcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICBtYXJnaW46IGF1dG87XFxuICAgICAgd2lkdGg6IDkwJTtcXG4gICAgICAuY29sdW1ue1xcbiAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgfVxcbiAgICB9ICBcXG4gIH1cXG4gIHRhYmxle1xcbiAgICBmb250LXNpemU6IDAuOWVtO1xcbiAgfVxcbiAgLmNvbnRhY3QsIGZvb3RlcntcXG4gICAgLmNvbHVtbnN7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgLmNvbHVtbntcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTRweDtcXG4gICAgICAgIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmNvbnRhY3R7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return '@media '.concat(item[2], ' {').concat(content, '}');\n            }\n            return content;\n        }).join('');\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    ''\n                ]\n            ];\n        }\n        var alreadyImportedModules = {\n        };\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join('\\n');\n    }\n    return [\n        content\n    ].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);\n    return '/*# '.concat(data, ' */');\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcz9jYTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi8gLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBsaXN0ID0gW10gLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICAgIDtcbiAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcbiAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdAbWVkaWEgJy5jb25jYXQoaXRlbVsyXSwgJyB7JykuY29uY2F0KGNvbnRlbnQsICd9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gJycuY29uY2F0KG1lZGlhUXVlcnksICcgYW5kICcpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBsaXN0O1xufTtcbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgICAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8qIyBzb3VyY2VVUkw9Jy5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCAnICovJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY29udGVudFxuICAgICAgICBdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ1xuICAgICAgICBdKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudFxuICAgIF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnLmNvbmNhdChiYXNlNjQpO1xuICAgIHJldHVybiAnLyojICcuY29uY2F0KGRhdGEsICcgKi8nKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkZfYXBwJmFic29sdXRlUGFnZVBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzYzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!\n");

/***/ }),

/***/ "./styles/globals.scss":
/*!*****************************!*\
  !*** ./styles/globals.scss ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!../node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./globals.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!../node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./globals.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!../node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./globals.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[2].oneOf[10].use[2]!./node_modules/next/dist/compiled/resolve-url-loader/index.js??ruleSet[1].rules[2].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[2].oneOf[10].use[4]!./styles/globals.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5zY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsNjJCQUFtYjs7QUFFcmQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sNjJCQUFtYjtBQUN6YjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDYyQkFBbWI7O0FBRTdjOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLnNjc3M/OTU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbMTBdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbMTBdLnVzZVsyXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzNdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzEwXS51c2VbNF0hLi9nbG9iYWxzLnNjc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzEwXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzEwXS51c2VbMl0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbMTBdLnVzZVszXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzRdIS4vZ2xvYmFscy5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZlsxMF0udXNlWzJdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzEwXS51c2VbM10hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbMTBdLnVzZVs0XSEuL2dsb2JhbHMuc2Nzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/globals.scss\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === 'undefined') {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {\n    };\n    return function memorize(target) {\n        if (typeof memo[target] === 'undefined') {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {\n    };\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + ' ' + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement('style');\n    const attributes = options.attributes || {\n    };\n    if (typeof attributes.nonce === 'undefined') {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === 'function') {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || 'head');\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join('\\n');\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute('media', media);\n    } else {\n        style.removeAttribute('media');\n    }\n    if (sourceMap && typeof btoa !== 'undefined') {\n        css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {\n    };\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== 'boolean') {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== '[object Array]') {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAgICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG59KCk7XG5jb25zdCBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gICAgY29uc3QgbWVtbyA9IHtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgICB9O1xufSgpO1xuY29uc3Qgc3R5bGVzSW5Eb20gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gLTE7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZENvdW50TWFwID0ge1xuICAgIH07XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBjb25zdCBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZCArICcgJyArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICAgIH07XG59KCk7XG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgICBjb25zdCBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/ICdAbWVkaWEgJyArIG9iai5tZWRpYSArICcgeycgKyBvYmouY3NzICsgJ30nIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICB9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaTErKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2kxXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.14.0\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = 0xeac7;\nvar REACT_PORTAL_TYPE = 0xeaca;\nexports.Fragment = 0xeacb;\nvar REACT_STRICT_MODE_TYPE = 0xeacc;\nvar REACT_PROFILER_TYPE = 0xead2;\nvar REACT_PROVIDER_TYPE = 0xeacd;\nvar REACT_CONTEXT_TYPE = 0xeace;\nvar REACT_FORWARD_REF_TYPE = 0xead0;\nvar REACT_SUSPENSE_TYPE = 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\nvar REACT_MEMO_TYPE = 0xead3;\nvar REACT_LAZY_TYPE = 0xead4;\nvar REACT_BLOCK_TYPE = 0xead9;\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\nvar REACT_SCOPE_TYPE = 0xead7;\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  exports.Fragment = symbolFor('react.fragment');\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_BLOCK_TYPE = symbolFor('react.block');\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n}\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = '';\n\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    }\n\n    stack += ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\nfunction describeComponentFrame (name, source, ownerName) {\n  var sourceInfo = '';\n\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n\n        if (match) {\n          var pathBeforeSlash = match[1];\n\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nvar Resolved = 1;\nfunction refineResolvedLazyComponent(lazyComponent) {\n  return lazyComponent._status === Resolved ? lazyComponent._result : null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case exports.Fragment:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type.render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var thenable = type;\n          var resolvedThenable = refineResolvedLazyComponent(thenable);\n\n          if (resolvedThenable) {\n            return getComponentName(resolvedThenable);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return null;\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar currentlyValidatingElement = null;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  currentlyValidatingElement = element;\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (Array.isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentName(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentName(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (Array.isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7O0FBRUEsV0FBVztBQUNYLFlBQVk7QUFDWixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz8yZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTQuMFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9ICcnO1xuXG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQudHlwZSk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkpO1xuICAgIH1cblxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHZhciBzb3VyY2VJbmZvID0gJyc7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcblxuICAgIHtcbiAgICAgIC8vIEluIERFViwgaW5jbHVkZSBjb2RlIGZvciBhIGNvbW1vbiBzcGVjaWFsIGNhc2U6XG4gICAgICAvLyBwcmVmZXIgXCJmb2xkZXIvaW5kZXguanNcIiBpbnN0ZWFkIG9mIGp1c3QgXCJpbmRleC5qc1wiLlxuICAgICAgaWYgKC9eaW5kZXhcXC4vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcGF0aEJlZm9yZVNsYXNoID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlSW5mbyA9ICcgKGF0ICcgKyBmaWxlTmFtZSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknO1xuICB9IGVsc2UgaWYgKG93bmVyTmFtZSkge1xuICAgIHNvdXJjZUluZm8gPSAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIHNvdXJjZUluZm87XG59XG5cbnZhciBSZXNvbHZlZCA9IDE7XG5mdW5jdGlvbiByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQobGF6eUNvbXBvbmVudCkge1xuICByZXR1cm4gbGF6eUNvbXBvbmVudC5fc3RhdHVzID09PSBSZXNvbHZlZCA/IGxhenlDb21wb25lbnQuX3Jlc3VsdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRUaGVuYWJsZSA9IHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudCh0aGVuYWJsZSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9ICBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyA7XG5cbmV4cG9ydHMuanN4ID0ganN4O1xuZXhwb3J0cy5qc3hzID0ganN4cztcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n");

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLCtJQUFrRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/MzRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n");

/***/ }),

/***/ "./node_modules/@prismicio/client/esm/@prismicio/client.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@prismicio/client/esm/@prismicio/client.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar Variation = /** @class */ (function () {\r\n    function Variation(data) {\r\n        this.data = {};\r\n        this.data = data;\r\n    }\r\n    Variation.prototype.id = function () {\r\n        return this.data.id;\r\n    };\r\n    Variation.prototype.ref = function () {\r\n        return this.data.ref;\r\n    };\r\n    Variation.prototype.label = function () {\r\n        return this.data.label;\r\n    };\r\n    return Variation;\r\n}());\r\nvar Experiment = /** @class */ (function () {\r\n    function Experiment(data) {\r\n        this.data = {};\r\n        this.data = data;\r\n        this.variations = (data.variations || []).map(function (v) {\r\n            return new Variation(v);\r\n        });\r\n    }\r\n    Experiment.prototype.id = function () {\r\n        return this.data.id;\r\n    };\r\n    Experiment.prototype.googleId = function () {\r\n        return this.data.googleId;\r\n    };\r\n    Experiment.prototype.name = function () {\r\n        return this.data.name;\r\n    };\r\n    return Experiment;\r\n}());\r\nvar Experiments = /** @class */ (function () {\r\n    function Experiments(data) {\r\n        if (data) {\r\n            this.drafts = (data.drafts || []).map(function (exp) {\r\n                return new Experiment(exp);\r\n            });\r\n            this.running = (data.running || []).map(function (exp) {\r\n                return new Experiment(exp);\r\n            });\r\n        }\r\n    }\r\n    Experiments.prototype.current = function () {\r\n        if (this.running.length > 0) {\r\n            return this.running[0];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Experiments.prototype.refFromCookie = function (cookie) {\r\n        if (!cookie || cookie.trim() === '')\r\n            return null;\r\n        var splitted = cookie.trim().split(' ');\r\n        if (splitted.length < 2)\r\n            return null;\r\n        var expId = splitted[0];\r\n        var varIndex = parseInt(splitted[1], 10);\r\n        var exp = this.running.filter(function (exp) {\r\n            return exp.googleId() === expId && exp.variations.length > varIndex;\r\n        })[0];\r\n        return exp ? exp.variations[varIndex].ref() : null;\r\n    };\r\n    return Experiments;\r\n}());\n\nvar LazySearchForm = /** @class */ (function () {\r\n    function LazySearchForm(id, api) {\r\n        this.id = id;\r\n        this.api = api;\r\n        this.fields = {};\r\n    }\r\n    LazySearchForm.prototype.set = function (key, value) {\r\n        this.fields[key] = value;\r\n        return this;\r\n    };\r\n    LazySearchForm.prototype.ref = function (ref) {\r\n        return this.set('ref', ref);\r\n    };\r\n    LazySearchForm.prototype.query = function (query) {\r\n        return this.set('q', query);\r\n    };\r\n    LazySearchForm.prototype.pageSize = function (size) {\r\n        return this.set('pageSize', size);\r\n    };\r\n    LazySearchForm.prototype.graphQuery = function (query) {\r\n        return this.set('graphQuery', query);\r\n    };\r\n    LazySearchForm.prototype.lang = function (langCode) {\r\n        return this.set('lang', langCode);\r\n    };\r\n    LazySearchForm.prototype.page = function (p) {\r\n        return this.set('page', p);\r\n    };\r\n    LazySearchForm.prototype.after = function (documentId) {\r\n        return this.set('after', documentId);\r\n    };\r\n    LazySearchForm.prototype.orderings = function (orderings) {\r\n        return this.set('orderings', orderings);\r\n    };\r\n    LazySearchForm.prototype.url = function () {\r\n        var _this = this;\r\n        return this.api.get().then(function (api) {\r\n            return LazySearchForm.toSearchForm(_this, api).url();\r\n        });\r\n    };\r\n    LazySearchForm.prototype.submit = function (cb) {\r\n        var _this = this;\r\n        return this.api.get().then(function (api) {\r\n            return LazySearchForm.toSearchForm(_this, api).submit(cb);\r\n        });\r\n    };\r\n    LazySearchForm.toSearchForm = function (lazyForm, api) {\r\n        var form = api.form(lazyForm.id);\r\n        if (form) {\r\n            return Object.keys(lazyForm.fields).reduce(function (form, fieldKey) {\r\n                var fieldValue = lazyForm.fields[fieldKey];\r\n                if (fieldKey === 'q') {\r\n                    return form.query(fieldValue);\r\n                }\r\n                else if (fieldKey === 'pageSize') {\r\n                    return form.pageSize(fieldValue);\r\n                }\r\n                else if (fieldKey === 'graphQuery') {\r\n                    return form.graphQuery(fieldValue);\r\n                }\r\n                else if (fieldKey === 'lang') {\r\n                    return form.lang(fieldValue);\r\n                }\r\n                else if (fieldKey === 'page') {\r\n                    return form.page(fieldValue);\r\n                }\r\n                else if (fieldKey === 'after') {\r\n                    return form.after(fieldValue);\r\n                }\r\n                else if (fieldKey === 'orderings') {\r\n                    return form.orderings(fieldValue);\r\n                }\r\n                else {\r\n                    return form.set(fieldKey, fieldValue);\r\n                }\r\n            }, form);\r\n        }\r\n        else {\r\n            throw new Error(\"Unable to access to form \" + lazyForm.id);\r\n        }\r\n    };\r\n    return LazySearchForm;\r\n}());\r\nvar SearchForm = /** @class */ (function () {\r\n    function SearchForm(form, httpClient) {\r\n        this.httpClient = httpClient;\r\n        this.form = form;\r\n        this.data = {};\r\n        for (var field in form.fields) {\r\n            if (form.fields[field]['default']) {\r\n                this.data[field] = [form.fields[field]['default']];\r\n            }\r\n        }\r\n    }\r\n    SearchForm.prototype.set = function (field, value) {\r\n        var fieldDesc = this.form.fields[field];\r\n        if (!fieldDesc)\r\n            throw new Error('Unknown field ' + field);\r\n        var checkedValue = value === '' || value === undefined ? null : value;\r\n        var values = this.data[field] || [];\r\n        if (fieldDesc.multiple) {\r\n            values = checkedValue ? values.concat([checkedValue]) : values;\r\n        }\r\n        else {\r\n            values = checkedValue ? [checkedValue] : values;\r\n        }\r\n        this.data[field] = values;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets a ref to query on for this SearchForm. This is a mandatory\r\n     * method to call before calling submit(), and api.form('everything').submit()\r\n     * will not work.\r\n     */\r\n    SearchForm.prototype.ref = function (ref) {\r\n        return this.set('ref', ref);\r\n    };\r\n    /**\r\n     * Sets a predicate-based query for this SearchForm. This is where you\r\n     * paste what you compose in your prismic.io API browser.\r\n     */\r\n    SearchForm.prototype.query = function (query) {\r\n        if (typeof query === 'string') {\r\n            return this.query([query]);\r\n        }\r\n        else if (Array.isArray(query)) {\r\n            return this.set('q', \"[\" + query.join('') + \"]\");\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid query : \" + query);\r\n        }\r\n    };\r\n    /**\r\n     * Sets a page size to query for this SearchForm. This is an optional method.\r\n     *\r\n     * @param {number} size - The page size\r\n     * @returns {SearchForm} - The SearchForm itself\r\n     */\r\n    SearchForm.prototype.pageSize = function (size) {\r\n        return this.set('pageSize', size);\r\n    };\r\n    /**\r\n     * Sets the graphquery to query for this SearchForm. This is an optional method.\r\n     */\r\n    SearchForm.prototype.graphQuery = function (query) {\r\n        return this.set('graphQuery', query);\r\n    };\r\n    /**\r\n     * Sets the language to query for this SearchForm. This is an optional method.\r\n     */\r\n    SearchForm.prototype.lang = function (langCode) {\r\n        return this.set('lang', langCode);\r\n    };\r\n    /**\r\n     * Sets the page number to query for this SearchForm. This is an optional method.\r\n     */\r\n    SearchForm.prototype.page = function (p) {\r\n        return this.set('page', p);\r\n    };\r\n    /**\r\n     * Remove all the documents except for those after the specified document in the list. This is an optional method.\r\n     */\r\n    SearchForm.prototype.after = function (documentId) {\r\n        return this.set('after', documentId);\r\n    };\r\n    /**\r\n     * Sets the orderings to query for this SearchForm. This is an optional method.\r\n     */\r\n    SearchForm.prototype.orderings = function (orderings) {\r\n        if (!orderings) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.set('orderings', \"[\" + orderings.join(',') + \"]\");\r\n        }\r\n    };\r\n    /**\r\n     * Build the URL to query\r\n     */\r\n    SearchForm.prototype.url = function () {\r\n        var url = this.form.action;\r\n        if (this.data) {\r\n            var sep = (url.indexOf('?') > -1 ? '&' : '?');\r\n            for (var key in this.data) {\r\n                if (Object.prototype.hasOwnProperty.call(this.data, key)) {\r\n                    var values = this.data[key];\r\n                    if (values) {\r\n                        for (var i = 0; i < values.length; i++) {\r\n                            url += sep + key + '=' + encodeURIComponent(values[i]);\r\n                            sep = '&';\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return url;\r\n    };\r\n    /**\r\n     * Submits the query, and calls the callback function.\r\n     */\r\n    SearchForm.prototype.submit = function (cb) {\r\n        return this.httpClient.cachedRequest(this.url()).then(function (response) {\r\n            cb && cb(null, response);\r\n            return response;\r\n        }).catch(function (error) {\r\n            cb && cb(error);\r\n            throw error;\r\n        });\r\n    };\r\n    return SearchForm;\r\n}());\n\nvar OPERATOR = {\r\n    at: 'at',\r\n    not: 'not',\r\n    missing: 'missing',\r\n    has: 'has',\r\n    any: 'any',\r\n    in: 'in',\r\n    fulltext: 'fulltext',\r\n    similar: 'similar',\r\n    numberGt: 'number.gt',\r\n    numberLt: 'number.lt',\r\n    numberInRange: 'number.inRange',\r\n    dateBefore: 'date.before',\r\n    dateAfter: 'date.after',\r\n    dateBetween: 'date.between',\r\n    dateDayOfMonth: 'date.day-of-month',\r\n    dateDayOfMonthAfter: 'date.day-of-month-after',\r\n    dateDayOfMonthBefore: 'date.day-of-month-before',\r\n    dateDayOfWeek: 'date.day-of-week',\r\n    dateDayOfWeekAfter: 'date.day-of-week-after',\r\n    dateDayOfWeekBefore: 'date.day-of-week-before',\r\n    dateMonth: 'date.month',\r\n    dateMonthBefore: 'date.month-before',\r\n    dateMonthAfter: 'date.month-after',\r\n    dateYear: 'date.year',\r\n    dateHour: 'date.hour',\r\n    dateHourBefore: 'date.hour-before',\r\n    dateHourAfter: 'date.hour-after',\r\n    GeopointNear: 'geopoint.near',\r\n};\r\nfunction encode(value) {\r\n    if (typeof value === 'string') {\r\n        return \"\\\"\" + value + \"\\\"\";\r\n    }\r\n    else if (typeof value === 'number') {\r\n        return value.toString();\r\n    }\r\n    else if (value instanceof Date) {\r\n        return value.getTime().toString();\r\n    }\r\n    else if (Array.isArray(value)) {\r\n        return \"[\" + value.map(function (v) { return encode(v); }).join(',') + \"]\";\r\n    }\r\n    else if (typeof value === \"boolean\") {\r\n        return value.toString();\r\n    }\r\n    else {\r\n        throw new Error(\"Unable to encode \" + value + \" of type \" + typeof value);\r\n    }\r\n}\r\nvar geopoint = {\r\n    near: function (fragment, latitude, longitude, radius) {\r\n        return \"[\" + OPERATOR.GeopointNear + \"(\" + fragment + \", \" + latitude + \", \" + longitude + \", \" + radius + \")]\";\r\n    },\r\n};\r\nvar date = {\r\n    before: function (fragment, before) {\r\n        return \"[\" + OPERATOR.dateBefore + \"(\" + fragment + \", \" + encode(before) + \")]\";\r\n    },\r\n    after: function (fragment, after) {\r\n        return \"[\" + OPERATOR.dateAfter + \"(\" + fragment + \", \" + encode(after) + \")]\";\r\n    },\r\n    between: function (fragment, before, after) {\r\n        return \"[\" + OPERATOR.dateBetween + \"(\" + fragment + \", \" + encode(before) + \", \" + encode(after) + \")]\";\r\n    },\r\n    dayOfMonth: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfMonth + \"(\" + fragment + \", \" + day + \")]\";\r\n    },\r\n    dayOfMonthAfter: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfMonthAfter + \"(\" + fragment + \", \" + day + \")]\";\r\n    },\r\n    dayOfMonthBefore: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfMonthBefore + \"(\" + fragment + \", \" + day + \")]\";\r\n    },\r\n    dayOfWeek: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfWeek + \"(\" + fragment + \", \" + encode(day) + \")]\";\r\n    },\r\n    dayOfWeekAfter: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfWeekAfter + \"(\" + fragment + \", \" + encode(day) + \")]\";\r\n    },\r\n    dayOfWeekBefore: function (fragment, day) {\r\n        return \"[\" + OPERATOR.dateDayOfWeekBefore + \"(\" + fragment + \", \" + encode(day) + \")]\";\r\n    },\r\n    month: function (fragment, month) {\r\n        return \"[\" + OPERATOR.dateMonth + \"(\" + fragment + \", \" + encode(month) + \")]\";\r\n    },\r\n    monthBefore: function (fragment, month) {\r\n        return \"[\" + OPERATOR.dateMonthBefore + \"(\" + fragment + \", \" + encode(month) + \")]\";\r\n    },\r\n    monthAfter: function (fragment, month) {\r\n        return \"[\" + OPERATOR.dateMonthAfter + \"(\" + fragment + \", \" + encode(month) + \")]\";\r\n    },\r\n    year: function (fragment, year) {\r\n        return \"[\" + OPERATOR.dateYear + \"(\" + fragment + \", \" + year + \")]\";\r\n    },\r\n    hour: function (fragment, hour) {\r\n        return \"[\" + OPERATOR.dateHour + \"(\" + fragment + \", \" + hour + \")]\";\r\n    },\r\n    hourBefore: function (fragment, hour) {\r\n        return \"[\" + OPERATOR.dateHourBefore + \"(\" + fragment + \", \" + hour + \")]\";\r\n    },\r\n    hourAfter: function (fragment, hour) {\r\n        return \"[\" + OPERATOR.dateHourAfter + \"(\" + fragment + \", \" + hour + \")]\";\r\n    },\r\n};\r\nvar number = {\r\n    gt: function (fragment, value) {\r\n        return \"[\" + OPERATOR.numberGt + \"(\" + fragment + \", \" + value + \")]\";\r\n    },\r\n    lt: function (fragment, value) {\r\n        return \"[\" + OPERATOR.numberLt + \"(\" + fragment + \", \" + value + \")]\";\r\n    },\r\n    inRange: function (fragment, before, after) {\r\n        return \"[\" + OPERATOR.numberInRange + \"(\" + fragment + \", \" + before + \", \" + after + \")]\";\r\n    },\r\n};\r\nvar Predicates = {\r\n    at: function (fragment, value) {\r\n        return \"[\" + OPERATOR.at + \"(\" + fragment + \", \" + encode(value) + \")]\";\r\n    },\r\n    not: function (fragment, value) {\r\n        return \"[\" + OPERATOR.not + \"(\" + fragment + \", \" + encode(value) + \")]\";\r\n    },\r\n    missing: function (fragment) {\r\n        return \"[\" + OPERATOR.missing + \"(\" + fragment + \")]\";\r\n    },\r\n    has: function (fragment) {\r\n        return \"[\" + OPERATOR.has + \"(\" + fragment + \")]\";\r\n    },\r\n    any: function (fragment, values) {\r\n        return \"[\" + OPERATOR.any + \"(\" + fragment + \", \" + encode(values) + \")]\";\r\n    },\r\n    in: function (fragment, values) {\r\n        return \"[\" + OPERATOR.in + \"(\" + fragment + \", \" + encode(values) + \")]\";\r\n    },\r\n    fulltext: function (fragment, value) {\r\n        return \"[\" + OPERATOR.fulltext + \"(\" + fragment + \", \" + encode(value) + \")]\";\r\n    },\r\n    similar: function (documentId, maxResults) {\r\n        return \"[\" + OPERATOR.similar + \"(\\\"\" + documentId + \"\\\", \" + maxResults + \")]\";\r\n    },\r\n    date: date,\r\n    dateBefore: date.before,\r\n    dateAfter: date.after,\r\n    dateBetween: date.between,\r\n    dayOfMonth: date.dayOfMonth,\r\n    dayOfMonthAfter: date.dayOfMonthAfter,\r\n    dayOfMonthBefore: date.dayOfMonthBefore,\r\n    dayOfWeek: date.dayOfWeek,\r\n    dayOfWeekAfter: date.dayOfWeekAfter,\r\n    dayOfWeekBefore: date.dayOfWeekBefore,\r\n    month: date.month,\r\n    monthBefore: date.monthBefore,\r\n    monthAfter: date.monthAfter,\r\n    year: date.year,\r\n    hour: date.hour,\r\n    hourBefore: date.hourBefore,\r\n    hourAfter: date.hourAfter,\r\n    number: number,\r\n    gt: number.gt,\r\n    lt: number.lt,\r\n    inRange: number.inRange,\r\n    near: geopoint.near,\r\n    geopoint: geopoint,\r\n};\n\n/* eslint-disable */\r\n// Some portions of code from https://github.com/jshttp/cookie\r\nvar decode = decodeURIComponent;\r\nfunction tryDecode(str, decode) {\r\n    try {\r\n        return decode(str);\r\n    }\r\n    catch (e) {\r\n        return str;\r\n    }\r\n}\r\nfunction parse(str, options) {\r\n    if (typeof str !== 'string') {\r\n        throw new TypeError('argument str must be a string');\r\n    }\r\n    var obj = {};\r\n    var opt = options || {};\r\n    var pairs = str.split(/; */);\r\n    var dec = opt.decode || decode;\r\n    pairs.forEach(function (pair) {\r\n        var eq_idx = pair.indexOf('=');\r\n        // skip things that don't look like key=value\r\n        if (eq_idx < 0) {\r\n            return;\r\n        }\r\n        var key = pair.substr(0, eq_idx).trim();\r\n        var val = pair.substr(++eq_idx, pair.length).trim();\r\n        // quoted values\r\n        if ('\"' == val[0]) {\r\n            val = val.slice(1, -1);\r\n        }\r\n        // only assign once\r\n        if (undefined == obj[key]) {\r\n            obj[key] = tryDecode(val, dec);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\nvar Cookies = { parse: parse };\n\nfunction createPreviewResolver(token, documentId, getDocByID) {\r\n    var resolve = function (linkResolver, defaultUrl, cb) {\r\n        if (documentId && getDocByID) {\r\n            return getDocByID(documentId, { ref: token }).then(function (document) {\r\n                if (!document) {\r\n                    cb && cb(null, defaultUrl);\r\n                    return defaultUrl;\r\n                }\r\n                else {\r\n                    var url = (linkResolver && linkResolver(document)) || document.url || defaultUrl;\r\n                    cb && cb(null, url);\r\n                    return url;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return Promise.resolve(defaultUrl);\r\n        }\r\n    };\r\n    return { token: token, documentId: documentId, resolve: resolve };\r\n}\n\nvar PREVIEW_COOKIE = 'io.prismic.preview';\r\nvar EXPERIMENT_COOKIE = 'io.prismic.experiment';\r\nvar ResolvedApi = /** @class */ (function () {\r\n    function ResolvedApi(data, httpClient, options) {\r\n        this.data = data;\r\n        this.masterRef = data.refs.filter(function (ref) { return ref.isMasterRef; })[0];\r\n        this.experiments = new Experiments(data.experiments);\r\n        this.bookmarks = data.bookmarks;\r\n        this.httpClient = httpClient;\r\n        this.options = options;\r\n        this.refs = data.refs;\r\n        this.tags = data.tags;\r\n        this.types = data.types;\r\n        this.languages = data.languages;\r\n    }\r\n    /**\r\n     * Returns a useable form from its id, as described in the RESTful description of the API.\r\n     * For instance: api.form(\"everything\") works on every repository (as \"everything\" exists by default)\r\n     * You can then chain the calls: api.form(\"everything\").query('[[:d = at(document.id, \"UkL0gMuvzYUANCpf\")]]').ref(ref).submit()\r\n     */\r\n    ResolvedApi.prototype.form = function (formId) {\r\n        var form = this.data.forms[formId];\r\n        if (form) {\r\n            return new SearchForm(form, this.httpClient);\r\n        }\r\n        return null;\r\n    };\r\n    ResolvedApi.prototype.everything = function () {\r\n        var f = this.form('everything');\r\n        if (!f)\r\n            throw new Error('Missing everything form');\r\n        return f;\r\n    };\r\n    /**\r\n     * The ID of the master ref on this prismic.io API.\r\n     * Do not use like this: searchForm.ref(api.master()).\r\n     * Instead, set your ref once in a variable, and call it when you need it; this will allow to change the ref you're viewing easily for your entire page.\r\n     */\r\n    ResolvedApi.prototype.master = function () {\r\n        return this.masterRef.ref;\r\n    };\r\n    /**\r\n     * Returns the ref ID for a given ref's label.\r\n     * Do not use like this: searchForm.ref(api.ref(\"Future release label\")).\r\n     * Instead, set your ref once in a variable, and call it when you need it; this will allow to change the ref you're viewing easily for your entire page.\r\n     */\r\n    ResolvedApi.prototype.ref = function (label) {\r\n        var ref = this.data.refs.filter(function (ref) { return ref.label === label; })[0];\r\n        return ref ? ref.ref : null;\r\n    };\r\n    ResolvedApi.prototype.currentExperiment = function () {\r\n        return this.experiments.current();\r\n    };\r\n    /**\r\n     * Query the repository\r\n     */\r\n    ResolvedApi.prototype.query = function (q, optionsOrCallback, cb) {\r\n        if (cb === void 0) { cb = function () { }; }\r\n        var _a = typeof optionsOrCallback === 'function'\r\n            ? { options: {}, callback: optionsOrCallback }\r\n            : { options: optionsOrCallback || {}, callback: cb }, options = _a.options, callback = _a.callback;\r\n        var form = this.everything();\r\n        for (var key in options) {\r\n            form = form.set(key, options[key]);\r\n        }\r\n        if (!options.ref) {\r\n            // Look in cookies if we have a ref (preview or experiment)\r\n            var cookieString = '';\r\n            if (this.options.req) { // NodeJS\r\n                cookieString = this.options.req.headers['cookie'] || '';\r\n            }\r\n            else if (typeof window !== 'undefined' && window.document) { // Browser\r\n                cookieString = window.document.cookie || '';\r\n            }\r\n            var cookies = Cookies.parse(cookieString);\r\n            var previewRef = cookies[PREVIEW_COOKIE];\r\n            var experimentRef = this.experiments.refFromCookie(cookies[EXPERIMENT_COOKIE]);\r\n            form = form.ref(previewRef || experimentRef || this.masterRef.ref);\r\n        }\r\n        if (q) {\r\n            form.query(q);\r\n        }\r\n        return form.submit(callback);\r\n    };\r\n    /**\r\n     * Retrieve the document returned by the given query\r\n     * @param {string|array|Predicate} the query\r\n     * @param {object} additional parameters. In NodeJS, pass the request as 'req'.\r\n     * @param {function} callback(err, doc)\r\n     */\r\n    ResolvedApi.prototype.queryFirst = function (q, optionsOrCallback, cb) {\r\n        var _a = typeof optionsOrCallback === 'function'\r\n            ? { options: {}, callback: optionsOrCallback }\r\n            : { options: optionsOrCallback || {}, callback: cb || (function () { }) }, options = _a.options, callback = _a.callback;\r\n        options.page = 1;\r\n        options.pageSize = 1;\r\n        return this.query(q, options).then(function (response) {\r\n            var document = response && response.results && response.results[0];\r\n            callback(null, document);\r\n            return document;\r\n        }).catch(function (error) {\r\n            callback(error);\r\n            throw error;\r\n        });\r\n    };\r\n    /**\r\n     * Retrieve the document with the given id\r\n     */\r\n    ResolvedApi.prototype.getByID = function (id, maybeOptions, cb) {\r\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\r\n        if (!options.lang)\r\n            options.lang = '*';\r\n        return this.queryFirst(Predicates.at('document.id', id), options, cb);\r\n    };\r\n    /**\r\n     * Retrieve multiple documents from an array of id\r\n     */\r\n    ResolvedApi.prototype.getByIDs = function (ids, maybeOptions, cb) {\r\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\r\n        if (!options.lang)\r\n            options.lang = '*';\r\n        return this.query(Predicates.in('document.id', ids), options, cb);\r\n    };\r\n    /**\r\n     * Retrieve the document with the given uid\r\n     */\r\n    ResolvedApi.prototype.getByUID = function (type, uid, maybeOptions, cb) {\r\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\r\n        if (options.lang === '*')\r\n            throw new Error(\"FORBIDDEN. You can't use getByUID with *, use the predicates instead.\");\r\n        if (!options.page)\r\n            options.page = 1;\r\n        return this.queryFirst(Predicates.at(\"my.\" + type + \".uid\", uid), options, cb);\r\n    };\r\n    /**\r\n     * Retrieve the singleton document with the given type\r\n     */\r\n    ResolvedApi.prototype.getSingle = function (type, maybeOptions, cb) {\r\n        var options = maybeOptions ? __assign({}, maybeOptions) : {};\r\n        return this.queryFirst(Predicates.at('document.type', type), options, cb);\r\n    };\r\n    /**\r\n     * Retrieve the document with the given bookmark\r\n     */\r\n    ResolvedApi.prototype.getBookmark = function (bookmark, maybeOptions, cb) {\r\n        var id = this.data.bookmarks[bookmark];\r\n        if (id) {\r\n            return this.getByID(id, maybeOptions, cb);\r\n        }\r\n        else {\r\n            return Promise.reject('Error retrieving bookmarked id');\r\n        }\r\n    };\r\n    ResolvedApi.prototype.getPreviewResolver = function (token, documentId) {\r\n        return createPreviewResolver(token, documentId, this.getByID.bind(this));\r\n    };\r\n    return ResolvedApi;\r\n}());\n\n/* eslint-disable */\r\n/**\r\n* A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\r\n* recently used items while discarding least recently used items when its limit\r\n* is reached.\r\n*\r\n* Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\r\n* Typescript-ified by Oleksandr Nikitin <https://tvori.info>\r\n*\r\n* Illustration of the design:\r\n*\r\n*       entry             entry             entry             entry\r\n*       ______            ______            ______            ______\r\n*      | head |.newer => |      |.newer => |      |.newer => | tail |\r\n*      |  A   |          |  B   |          |  C   |          |  D   |\r\n*      |______| <= older.|______| <= older.|______| <= older.|______|\r\n*\r\n*  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\r\n*/\r\nfunction MakeLRUCache(limit) {\r\n    return new LRUCache(limit);\r\n}\r\nfunction LRUCache(limit) {\r\n    // Current size of the cache. (Read-only).\r\n    this.size = 0;\r\n    // Maximum number of items this cache can hold.\r\n    this.limit = limit;\r\n    this._keymap = {};\r\n}\r\n/**\r\n * Put <value> into the cache associated with <key>. Returns the entry which was\r\n * removed to make room for the new entry. Otherwise undefined is returned\r\n * (i.e. if there was enough room already).\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    var entry = { key: key, value: value };\r\n    // Note: No protection agains replacing, and thus orphan entries. By design.\r\n    this._keymap[key] = entry;\r\n    if (this.tail) {\r\n        // link previous tail to the new tail (entry)\r\n        this.tail.newer = entry;\r\n        entry.older = this.tail;\r\n    }\r\n    else {\r\n        // we're first in -- yay\r\n        this.head = entry;\r\n    }\r\n    // add new entry to the end of the linked list -- it's now the freshest entry.\r\n    this.tail = entry;\r\n    if (this.size === this.limit) {\r\n        // we hit the limit -- remove the head\r\n        return this.shift();\r\n    }\r\n    else {\r\n        // increase the size counter\r\n        this.size++;\r\n    }\r\n};\r\n/**\r\n * Purge the least recently used (oldest) entry from the cache. Returns the\r\n * removed entry or undefined if the cache was empty.\r\n *\r\n * If you need to perform any form of finalization of purged items, this is a\r\n * good place to do it. Simply override/replace this function:\r\n *\r\n *   var c = new LRUCache(123);\r\n *   c.shift = function() {\r\n *     var entry = LRUCache.prototype.shift.call(this);\r\n *     doSomethingWith(entry);\r\n *     return entry;\r\n *   }\r\n */\r\nLRUCache.prototype.shift = function () {\r\n    // todo: handle special case when limit == 1\r\n    var entry = this.head;\r\n    if (entry) {\r\n        if (this.head.newer) {\r\n            this.head = this.head.newer;\r\n            this.head.older = undefined;\r\n        }\r\n        else {\r\n            this.head = undefined;\r\n        }\r\n        // Remove last strong reference to <entry> and remove links from the purged\r\n        // entry being returned:\r\n        entry.newer = entry.older = undefined;\r\n        // delete is slow, but we need to do this to avoid uncontrollable growth:\r\n        delete this._keymap[entry.key];\r\n    }\r\n    console.log('purging ', entry.key);\r\n    return entry;\r\n};\r\n/**\r\n * Get and register recent use of <key>. Returns the value associated with <key>\r\n * or undefined if not in cache.\r\n */\r\nLRUCache.prototype.get = function (key, returnEntry) {\r\n    // First, find our cache entry\r\n    var entry = this._keymap[key];\r\n    if (entry === undefined)\r\n        return; // Not cached. Sorry.\r\n    // As <key> was found in the cache, register it as being requested recently\r\n    if (entry === this.tail) {\r\n        // Already the most recently used entry, so no need to update the list\r\n        return returnEntry ? entry : entry.value;\r\n    }\r\n    // HEAD--------------TAIL\r\n    //   <.older   .newer>\r\n    //  <--- add direction --\r\n    //   A  B  C  <D>  E\r\n    if (entry.newer) {\r\n        if (entry === this.head)\r\n            this.head = entry.newer;\r\n        entry.newer.older = entry.older; // C <-- E.\r\n    }\r\n    if (entry.older)\r\n        entry.older.newer = entry.newer; // C. --> E\r\n    entry.newer = undefined; // D --x\r\n    entry.older = this.tail; // D. --> E\r\n    if (this.tail)\r\n        this.tail.newer = entry; // E. <-- D\r\n    this.tail = entry;\r\n    return returnEntry ? entry : entry.value;\r\n};\r\n// ----------------------------------------------------------------------------\r\n// Following code is optional and can be removed without breaking the core\r\n// functionality.\r\n/**\r\n * Check if <key> is in the cache without registering recent use. Feasible if\r\n * you do not want to chage the state of the cache, but only \"peek\" at it.\r\n * Returns the entry associated with <key> if found, or undefined if not found.\r\n */\r\nLRUCache.prototype.find = function (key) {\r\n    return this._keymap[key];\r\n};\r\n/**\r\n * Update the value of entry with <key>. Returns the old value, or undefined if\r\n * entry was not in the cache.\r\n */\r\nLRUCache.prototype.set = function (key, value) {\r\n    var oldvalue;\r\n    var entry = this.get(key, true);\r\n    if (entry) {\r\n        oldvalue = entry.value;\r\n        entry.value = value;\r\n    }\r\n    else {\r\n        oldvalue = this.put(key, value);\r\n        if (oldvalue)\r\n            oldvalue = oldvalue.value;\r\n    }\r\n    return oldvalue;\r\n};\r\n/**\r\n * Remove entry <key> from cache and return its value. Returns undefined if not\r\n * found.\r\n */\r\nLRUCache.prototype.remove = function (key) {\r\n    var entry = this._keymap[key];\r\n    if (!entry)\r\n        return;\r\n    delete this._keymap[entry.key]; // need to do delete unfortunately\r\n    if (entry.newer && entry.older) {\r\n        // relink the older entry with the newer entry\r\n        entry.older.newer = entry.newer;\r\n        entry.newer.older = entry.older;\r\n    }\r\n    else if (entry.newer) {\r\n        // remove the link to us\r\n        entry.newer.older = undefined;\r\n        // link the newer entry to head\r\n        this.head = entry.newer;\r\n    }\r\n    else if (entry.older) {\r\n        // remove the link to us\r\n        entry.older.newer = undefined;\r\n        // link the newer entry to head\r\n        this.tail = entry.older;\r\n    }\r\n    else { // if(entry.older === undefined && entry.newer === undefined) {\r\n        this.head = this.tail = undefined;\r\n    }\r\n    this.size--;\r\n    return entry.value;\r\n};\r\n/** Removes all entries */\r\nLRUCache.prototype.removeAll = function () {\r\n    // This should be safe, as we never expose strong refrences to the outside\r\n    this.head = this.tail = undefined;\r\n    this.size = 0;\r\n    this._keymap = {};\r\n};\r\n/**\r\n * Return an array containing all keys of entries stored in the cache object, in\r\n * arbitrary order.\r\n */\r\nif (typeof Object.keys === 'function') {\r\n    LRUCache.prototype.keys = function () { return Object.keys(this._keymap); };\r\n}\r\nelse {\r\n    LRUCache.prototype.keys = function () {\r\n        var keys = [];\r\n        for (var k in this._keymap)\r\n            keys.push(k);\r\n        return keys;\r\n    };\r\n}\r\n/**\r\n * Call `fun` for each entry. Starting with the newest entry if `desc` is a true\r\n * value, otherwise starts with the oldest (head) enrty and moves towards the\r\n * tail.\r\n *\r\n * `fun` is called with 3 arguments in the context `context`:\r\n *   `fun.call(context, Object key, Object value, LRUCache self)`\r\n */\r\nLRUCache.prototype.forEach = function (fun, context, desc) {\r\n    var entry;\r\n    if (context === true) {\r\n        desc = true;\r\n        context = undefined;\r\n    }\r\n    else if (typeof context !== 'object')\r\n        context = this;\r\n    if (desc) {\r\n        entry = this.tail;\r\n        while (entry) {\r\n            fun.call(context, entry.key, entry.value, this);\r\n            entry = entry.older;\r\n        }\r\n    }\r\n    else {\r\n        entry = this.head;\r\n        while (entry) {\r\n            fun.call(context, entry.key, entry.value, this);\r\n            entry = entry.newer;\r\n        }\r\n    }\r\n};\r\n/** Returns a JSON (array) representation */\r\n//LRUCache.prototype.toJSON = function () {\r\n//    var s: IEntry[] = [], entry = this.head;\r\n//    while (entry) {\r\n//        s.push({ key: entry.key.toJSON(), value: entry.value.toJSON() });\r\n//        entry = entry.newer;\r\n//    }\r\n//    return s;\r\n//};\r\n/** Returns a String representation */\r\nLRUCache.prototype.toString = function () {\r\n    var s = '', entry = this.head;\r\n    while (entry) {\r\n        s += String(entry.key) + ':' + entry.value;\r\n        entry = entry.newer;\r\n        if (entry)\r\n            s += ' < ';\r\n    }\r\n    return s;\r\n};\r\n// Export ourselves\r\n//if (typeof this === 'object') this.LRUCache = LRUCache;\n\nvar DefaultApiCache = /** @class */ (function () {\r\n    function DefaultApiCache(limit) {\r\n        if (limit === void 0) { limit = 1000; }\r\n        this.lru = MakeLRUCache(limit);\r\n    }\r\n    DefaultApiCache.prototype.isExpired = function (key) {\r\n        var value = this.lru.get(key, false);\r\n        if (value) {\r\n            return value.expiredIn !== 0 && value.expiredIn < Date.now();\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    DefaultApiCache.prototype.get = function (key, cb) {\r\n        var value = this.lru.get(key, false);\r\n        if (value && !this.isExpired(key)) {\r\n            cb(null, value.data);\r\n        }\r\n        else {\r\n            cb && cb(null);\r\n        }\r\n    };\r\n    DefaultApiCache.prototype.set = function (key, value, ttl, cb) {\r\n        this.lru.remove(key);\r\n        this.lru.put(key, {\r\n            data: value,\r\n            expiredIn: ttl ? (Date.now() + (ttl * 1000)) : 0,\r\n        });\r\n        cb && cb(null);\r\n    };\r\n    DefaultApiCache.prototype.remove = function (key, cb) {\r\n        this.lru.remove(key);\r\n        cb && cb(null);\r\n    };\r\n    DefaultApiCache.prototype.clear = function (cb) {\r\n        this.lru.removeAll();\r\n        cb && cb(null);\r\n    };\r\n    return DefaultApiCache;\r\n}());\n\nfunction fetchRequest(url, options, callback) {\r\n    var fetchOptions = {\r\n        headers: {\r\n            Accept: 'application/json',\r\n        },\r\n    };\r\n    if (options && options.proxyAgent) {\r\n        fetchOptions.agent = options.proxyAgent;\r\n    }\r\n    // can't use number because of NodeJS globals included\r\n    var timeoutId;\r\n    var fetchPromise = cross_fetch__WEBPACK_IMPORTED_MODULE_0__(url, fetchOptions);\r\n    var promise = options.timeoutInMs ? Promise.race([\r\n        fetchPromise,\r\n        new Promise(function (_, reject) {\r\n            timeoutId = setTimeout(function () { return reject(new Error(url + \" response timeout\")); }, options.timeoutInMs);\r\n        })\r\n    ]) : fetchPromise;\r\n    promise.then(function (resp) {\r\n        clearTimeout(timeoutId);\r\n        if (~~(resp.status / 100 !== 2)) {\r\n            /**\r\n             * @description\r\n             * drain the resp before throwing an error to prevent memory leaks\r\n             * @link https://github.com/bitinn/node-fetch/issues/83\r\n             */\r\n            return resp.text().then(function () {\r\n                var e = new Error(\"Unexpected status code [\" + resp.status + \"] on URL \" + url);\r\n                e.status = resp.status;\r\n                throw e;\r\n            });\r\n        }\r\n        return resp.json().then(function (result) {\r\n            var cacheControl = resp.headers.get('cache-control');\r\n            var parsedCacheControl = cacheControl ? /max-age=(\\d+)/.exec(cacheControl) : null;\r\n            var ttl = parsedCacheControl ? parseInt(parsedCacheControl[1], 10) : undefined;\r\n            callback(null, result, resp, ttl);\r\n        });\r\n    }).catch(function (err) {\r\n        clearTimeout(timeoutId);\r\n        callback(err);\r\n    });\r\n}\r\nvar DefaultRequestHandler = /** @class */ (function () {\r\n    function DefaultRequestHandler(options) {\r\n        this.options = options || {};\r\n    }\r\n    DefaultRequestHandler.prototype.request = function (url, callback) {\r\n        fetchRequest(url, this.options, callback);\r\n    };\r\n    return DefaultRequestHandler;\r\n}());\n\nvar HttpClient = /** @class */ (function () {\r\n    function HttpClient(requestHandler, cache, proxyAgent, timeoutInMs) {\r\n        this.requestHandler = requestHandler || new DefaultRequestHandler({ proxyAgent: proxyAgent, timeoutInMs: timeoutInMs });\r\n        this.cache = cache || new DefaultApiCache();\r\n    }\r\n    HttpClient.prototype.request = function (url, callback) {\r\n        this.requestHandler.request(url, function (err, result, xhr, ttl) {\r\n            if (err) {\r\n                callback && callback(err, null, xhr, ttl);\r\n            }\r\n            else if (result) {\r\n                callback && callback(null, result, xhr, ttl);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Fetch a URL corresponding to a query, and parse the response as a Response object\r\n     */\r\n    HttpClient.prototype.cachedRequest = function (url, maybeOptions) {\r\n        var _this = this;\r\n        var options = maybeOptions || {};\r\n        var run = function (cb) {\r\n            var cacheKey = options.cacheKey || url;\r\n            _this.cache.get(cacheKey, function (cacheGetError, cacheGetValue) {\r\n                if (cacheGetError || cacheGetValue) {\r\n                    cb(cacheGetError, cacheGetValue);\r\n                }\r\n                else {\r\n                    _this.request(url, function (fetchError, fetchValue, _, ttlReq) {\r\n                        if (fetchError) {\r\n                            cb(fetchError, null);\r\n                        }\r\n                        else {\r\n                            var ttl = ttlReq || options.ttl;\r\n                            if (ttl) {\r\n                                _this.cache.set(cacheKey, fetchValue, ttl, cb);\r\n                            }\r\n                            cb(null, fetchValue);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        return new Promise(function (resolve, reject) {\r\n            run(function (err, value) {\r\n                if (err)\r\n                    reject(err);\r\n                if (value)\r\n                    resolve(value);\r\n            });\r\n        });\r\n    };\r\n    return HttpClient;\r\n}());\n\nfunction separator(url) {\r\n    return url.indexOf('?') > -1 ? '&' : '?';\r\n}\r\nvar Api = /** @class */ (function () {\r\n    function Api(url, options) {\r\n        this.options = options || {};\r\n        this.url = url;\r\n        var queryStrings = [\r\n            this.options.accessToken && \"access_token=\" + this.options.accessToken,\r\n            this.options.routes && \"routes=\" + encodeURIComponent(JSON.stringify(this.options.routes))\r\n        ]\r\n            .filter(Boolean);\r\n        if (queryStrings.length > 0) {\r\n            this.url += separator(url) + queryStrings.join('&');\r\n        }\r\n        this.apiDataTTL = this.options.apiDataTTL || 5;\r\n        this.httpClient = new HttpClient(this.options.requestHandler, this.options.apiCache, this.options.proxyAgent, this.options.timeoutInMs);\r\n    }\r\n    /**\r\n     * Fetches data used to construct the api client, from cache if it's\r\n     * present, otherwise from calling the prismic api endpoint (which is\r\n     * then cached).\r\n     */\r\n    Api.prototype.get = function (cb) {\r\n        var _this = this;\r\n        return this.httpClient.cachedRequest(this.url, { ttl: this.apiDataTTL }).then(function (data) {\r\n            var resolvedApi = new ResolvedApi(data, _this.httpClient, _this.options);\r\n            cb && cb(null, resolvedApi);\r\n            return resolvedApi;\r\n        }).catch(function (error) {\r\n            cb && cb(error);\r\n            throw error;\r\n        });\r\n    };\r\n    return Api;\r\n}());\n\nvar DefaultClient = /** @class */ (function () {\r\n    function DefaultClient(url, options) {\r\n        this.api = new Api(url, options);\r\n    }\r\n    DefaultClient.prototype.getApi = function () {\r\n        return this.api.get();\r\n    };\r\n    DefaultClient.prototype.everything = function () {\r\n        return this.form('everything');\r\n    };\r\n    DefaultClient.prototype.form = function (formId) {\r\n        return new LazySearchForm(formId, this.api);\r\n    };\r\n    DefaultClient.prototype.query = function (q, optionsOrCallback, cb) {\r\n        return this.getApi().then(function (api) { return api.query(q, optionsOrCallback, cb); });\r\n    };\r\n    DefaultClient.prototype.queryFirst = function (q, optionsOrCallback, cb) {\r\n        return this.getApi().then(function (api) { return api.queryFirst(q, optionsOrCallback, cb); });\r\n    };\r\n    DefaultClient.prototype.getByID = function (id, options, cb) {\r\n        return this.getApi().then(function (api) { return api.getByID(id, options, cb); });\r\n    };\r\n    DefaultClient.prototype.getByIDs = function (ids, options, cb) {\r\n        return this.getApi().then(function (api) { return api.getByIDs(ids, options, cb); });\r\n    };\r\n    DefaultClient.prototype.getByUID = function (type, uid, options, cb) {\r\n        return this.getApi().then(function (api) { return api.getByUID(type, uid, options, cb); });\r\n    };\r\n    DefaultClient.prototype.getSingle = function (type, options, cb) {\r\n        return this.getApi().then(function (api) { return api.getSingle(type, options, cb); });\r\n    };\r\n    DefaultClient.prototype.getBookmark = function (bookmark, options, cb) {\r\n        return this.getApi().then(function (api) { return api.getBookmark(bookmark, options, cb); });\r\n    };\r\n    DefaultClient.prototype.getPreviewResolver = function (token, documentId) {\r\n        var _this = this;\r\n        var getDocById = function (documentId, maybeOptions) { return _this.getApi().then(function (api) {\r\n            return api.getByID(documentId, maybeOptions);\r\n        }); };\r\n        return createPreviewResolver(token, documentId, getDocById);\r\n    };\r\n    DefaultClient.getApi = function (url, options) {\r\n        var api = new Api(url, options);\r\n        return api.get();\r\n    };\r\n    return DefaultClient;\r\n}());\n\nvar index = {\r\n    experimentCookie: EXPERIMENT_COOKIE,\r\n    previewCookie: PREVIEW_COOKIE,\r\n    Predicates: Predicates,\r\n    predicates: Predicates,\r\n    Experiments: Experiments,\r\n    Api: Api,\r\n    client: client,\r\n    getApi: getApi,\r\n    api: api,\r\n};\r\nfunction client(url, options) {\r\n    return new DefaultClient(url, options);\r\n}\r\nfunction getApi(url, options) {\r\n    return DefaultClient.getApi(url, options);\r\n}\r\nfunction api(url, options) {\r\n    return getApi(url, options);\r\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceMappingURL=client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtaWNpby9jbGllbnQvZXNtL0BwcmlzbWljaW8vY2xpZW50Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFxQzs7QUFFckM7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQTZDO0FBQ2hHO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtEO0FBQ3JHO0FBQ0E7QUFDQSxtREFBbUQsc0NBQXNDO0FBQ3pGO0FBQ0E7QUFDQSxtREFBbUQsd0NBQXdDO0FBQzNGO0FBQ0E7QUFDQSxtREFBbUQsOENBQThDO0FBQ2pHO0FBQ0E7QUFDQSxtREFBbUQsMENBQTBDO0FBQzdGO0FBQ0E7QUFDQSxtREFBbUQsZ0RBQWdEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxLQUFLLEVBQUM7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWljaW8vY2xpZW50L2VzbS9AcHJpc21pY2lvL2NsaWVudC5tanM/MGQxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3Jvc3NGZXRjaCBmcm9tICdjcm9zcy1mZXRjaCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgVmFyaWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFyaWF0aW9uKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgVmFyaWF0aW9uLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmlkO1xyXG4gICAgfTtcclxuICAgIFZhcmlhdGlvbi5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEucmVmO1xyXG4gICAgfTtcclxuICAgIFZhcmlhdGlvbi5wcm90b3R5cGUubGFiZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sYWJlbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFyaWF0aW9uO1xyXG59KCkpO1xyXG52YXIgRXhwZXJpbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4cGVyaW1lbnQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy52YXJpYXRpb25zID0gKGRhdGEudmFyaWF0aW9ucyB8fCBbXSkubWFwKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFyaWF0aW9uKHYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRXhwZXJpbWVudC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pZDtcclxuICAgIH07XHJcbiAgICBFeHBlcmltZW50LnByb3RvdHlwZS5nb29nbGVJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdvb2dsZUlkO1xyXG4gICAgfTtcclxuICAgIEV4cGVyaW1lbnQucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFeHBlcmltZW50O1xyXG59KCkpO1xyXG52YXIgRXhwZXJpbWVudHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFeHBlcmltZW50cyhkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFmdHMgPSAoZGF0YS5kcmFmdHMgfHwgW10pLm1hcChmdW5jdGlvbiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cGVyaW1lbnQoZXhwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IChkYXRhLnJ1bm5pbmcgfHwgW10pLm1hcChmdW5jdGlvbiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV4cGVyaW1lbnQoZXhwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRXhwZXJpbWVudHMucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmdbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXhwZXJpbWVudHMucHJvdG90eXBlLnJlZkZyb21Db29raWUgPSBmdW5jdGlvbiAoY29va2llKSB7XHJcbiAgICAgICAgaWYgKCFjb29raWUgfHwgY29va2llLnRyaW0oKSA9PT0gJycpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IGNvb2tpZS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgICAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoIDwgMilcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGV4cElkID0gc3BsaXR0ZWRbMF07XHJcbiAgICAgICAgdmFyIHZhckluZGV4ID0gcGFyc2VJbnQoc3BsaXR0ZWRbMV0sIDEwKTtcclxuICAgICAgICB2YXIgZXhwID0gdGhpcy5ydW5uaW5nLmZpbHRlcihmdW5jdGlvbiAoZXhwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHAuZ29vZ2xlSWQoKSA9PT0gZXhwSWQgJiYgZXhwLnZhcmlhdGlvbnMubGVuZ3RoID4gdmFySW5kZXg7XHJcbiAgICAgICAgfSlbMF07XHJcbiAgICAgICAgcmV0dXJuIGV4cCA/IGV4cC52YXJpYXRpb25zW3ZhckluZGV4XS5yZWYoKSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV4cGVyaW1lbnRzO1xyXG59KCkpO1xuXG52YXIgTGF6eVNlYXJjaEZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYXp5U2VhcmNoRm9ybShpZCwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xyXG4gICAgICAgIHRoaXMuZmllbGRzID0ge307XHJcbiAgICB9XHJcbiAgICBMYXp5U2VhcmNoRm9ybS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZpZWxkc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF6eVNlYXJjaEZvcm0ucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3JlZicsIHJlZik7XHJcbiAgICB9O1xyXG4gICAgTGF6eVNlYXJjaEZvcm0ucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdxJywgcXVlcnkpO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnByb3RvdHlwZS5wYWdlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdwYWdlU2l6ZScsIHNpemUpO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnByb3RvdHlwZS5ncmFwaFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdncmFwaFF1ZXJ5JywgcXVlcnkpO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnByb3RvdHlwZS5sYW5nID0gZnVuY3Rpb24gKGxhbmdDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdsYW5nJywgbGFuZ0NvZGUpO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnByb3RvdHlwZS5wYWdlID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3BhZ2UnLCBwKTtcclxuICAgIH07XHJcbiAgICBMYXp5U2VhcmNoRm9ybS5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoZG9jdW1lbnRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgnYWZ0ZXInLCBkb2N1bWVudElkKTtcclxuICAgIH07XHJcbiAgICBMYXp5U2VhcmNoRm9ybS5wcm90b3R5cGUub3JkZXJpbmdzID0gZnVuY3Rpb24gKG9yZGVyaW5ncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgnb3JkZXJpbmdzJywgb3JkZXJpbmdzKTtcclxuICAgIH07XHJcbiAgICBMYXp5U2VhcmNoRm9ybS5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdldCgpLnRoZW4oZnVuY3Rpb24gKGFwaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTGF6eVNlYXJjaEZvcm0udG9TZWFyY2hGb3JtKF90aGlzLCBhcGkpLnVybCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnByb3RvdHlwZS5zdWJtaXQgPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5nZXQoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExhenlTZWFyY2hGb3JtLnRvU2VhcmNoRm9ybShfdGhpcywgYXBpKS5zdWJtaXQoY2IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIExhenlTZWFyY2hGb3JtLnRvU2VhcmNoRm9ybSA9IGZ1bmN0aW9uIChsYXp5Rm9ybSwgYXBpKSB7XHJcbiAgICAgICAgdmFyIGZvcm0gPSBhcGkuZm9ybShsYXp5Rm9ybS5pZCk7XHJcbiAgICAgICAgaWYgKGZvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhenlGb3JtLmZpZWxkcykucmVkdWNlKGZ1bmN0aW9uIChmb3JtLCBmaWVsZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkVmFsdWUgPSBsYXp5Rm9ybS5maWVsZHNbZmllbGRLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkS2V5ID09PSAncScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybS5xdWVyeShmaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkS2V5ID09PSAncGFnZVNpemUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0ucGFnZVNpemUoZmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZEtleSA9PT0gJ2dyYXBoUXVlcnknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0uZ3JhcGhRdWVyeShmaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkS2V5ID09PSAnbGFuZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybS5sYW5nKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRLZXkgPT09ICdwYWdlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtLnBhZ2UoZmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZEtleSA9PT0gJ2FmdGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtLmFmdGVyKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRLZXkgPT09ICdvcmRlcmluZ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0ub3JkZXJpbmdzKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm0uc2V0KGZpZWxkS2V5LCBmaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWNjZXNzIHRvIGZvcm0gXCIgKyBsYXp5Rm9ybS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBMYXp5U2VhcmNoRm9ybTtcclxufSgpKTtcclxudmFyIFNlYXJjaEZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWFyY2hGb3JtKGZvcm0sIGh0dHBDbGllbnQpIHtcclxuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xyXG4gICAgICAgIHRoaXMuZm9ybSA9IGZvcm07XHJcbiAgICAgICAgdGhpcy5kYXRhID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gZm9ybS5maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm0uZmllbGRzW2ZpZWxkXVsnZGVmYXVsdCddKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbZmllbGRdID0gW2Zvcm0uZmllbGRzW2ZpZWxkXVsnZGVmYXVsdCddXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFNlYXJjaEZvcm0ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgZmllbGREZXNjID0gdGhpcy5mb3JtLmZpZWxkc1tmaWVsZF07XHJcbiAgICAgICAgaWYgKCFmaWVsZERlc2MpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWVsZCAnICsgZmllbGQpO1xyXG4gICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSB2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhW2ZpZWxkXSB8fCBbXTtcclxuICAgICAgICBpZiAoZmllbGREZXNjLm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IGNoZWNrZWRWYWx1ZSA/IHZhbHVlcy5jb25jYXQoW2NoZWNrZWRWYWx1ZV0pIDogdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gY2hlY2tlZFZhbHVlID8gW2NoZWNrZWRWYWx1ZV0gOiB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YVtmaWVsZF0gPSB2YWx1ZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgcmVmIHRvIHF1ZXJ5IG9uIGZvciB0aGlzIFNlYXJjaEZvcm0uIFRoaXMgaXMgYSBtYW5kYXRvcnlcclxuICAgICAqIG1ldGhvZCB0byBjYWxsIGJlZm9yZSBjYWxsaW5nIHN1Ym1pdCgpLCBhbmQgYXBpLmZvcm0oJ2V2ZXJ5dGhpbmcnKS5zdWJtaXQoKVxyXG4gICAgICogd2lsbCBub3Qgd29yay5cclxuICAgICAqL1xyXG4gICAgU2VhcmNoRm9ybS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgncmVmJywgcmVmKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBwcmVkaWNhdGUtYmFzZWQgcXVlcnkgZm9yIHRoaXMgU2VhcmNoRm9ybS4gVGhpcyBpcyB3aGVyZSB5b3VcclxuICAgICAqIHBhc3RlIHdoYXQgeW91IGNvbXBvc2UgaW4geW91ciBwcmlzbWljLmlvIEFQSSBicm93c2VyLlxyXG4gICAgICovXHJcbiAgICBTZWFyY2hGb3JtLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KFtxdWVyeV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3EnLCBcIltcIiArIHF1ZXJ5LmpvaW4oJycpICsgXCJdXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBxdWVyeSA6IFwiICsgcXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBwYWdlIHNpemUgdG8gcXVlcnkgZm9yIHRoaXMgU2VhcmNoRm9ybS4gVGhpcyBpcyBhbiBvcHRpb25hbCBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgcGFnZSBzaXplXHJcbiAgICAgKiBAcmV0dXJucyB7U2VhcmNoRm9ybX0gLSBUaGUgU2VhcmNoRm9ybSBpdHNlbGZcclxuICAgICAqL1xyXG4gICAgU2VhcmNoRm9ybS5wcm90b3R5cGUucGFnZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgncGFnZVNpemUnLCBzaXplKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdyYXBocXVlcnkgdG8gcXVlcnkgZm9yIHRoaXMgU2VhcmNoRm9ybS4gVGhpcyBpcyBhbiBvcHRpb25hbCBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIFNlYXJjaEZvcm0ucHJvdG90eXBlLmdyYXBoUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ2dyYXBoUXVlcnknLCBxdWVyeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBsYW5ndWFnZSB0byBxdWVyeSBmb3IgdGhpcyBTZWFyY2hGb3JtLiBUaGlzIGlzIGFuIG9wdGlvbmFsIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgU2VhcmNoRm9ybS5wcm90b3R5cGUubGFuZyA9IGZ1bmN0aW9uIChsYW5nQ29kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgnbGFuZycsIGxhbmdDb2RlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBhZ2UgbnVtYmVyIHRvIHF1ZXJ5IGZvciB0aGlzIFNlYXJjaEZvcm0uIFRoaXMgaXMgYW4gb3B0aW9uYWwgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBTZWFyY2hGb3JtLnByb3RvdHlwZS5wYWdlID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3BhZ2UnLCBwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgdGhlIGRvY3VtZW50cyBleGNlcHQgZm9yIHRob3NlIGFmdGVyIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnQgaW4gdGhlIGxpc3QuIFRoaXMgaXMgYW4gb3B0aW9uYWwgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBTZWFyY2hGb3JtLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChkb2N1bWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdhZnRlcicsIGRvY3VtZW50SWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3JkZXJpbmdzIHRvIHF1ZXJ5IGZvciB0aGlzIFNlYXJjaEZvcm0uIFRoaXMgaXMgYW4gb3B0aW9uYWwgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBTZWFyY2hGb3JtLnByb3RvdHlwZS5vcmRlcmluZ3MgPSBmdW5jdGlvbiAob3JkZXJpbmdzKSB7XHJcbiAgICAgICAgaWYgKCFvcmRlcmluZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ29yZGVyaW5ncycsIFwiW1wiICsgb3JkZXJpbmdzLmpvaW4oJywnKSArIFwiXVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCB0aGUgVVJMIHRvIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIFNlYXJjaEZvcm0ucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdXJsID0gdGhpcy5mb3JtLmFjdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXAgPSAodXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nKTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IHNlcCArIGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwID0gJyYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJtaXRzIHRoZSBxdWVyeSwgYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgU2VhcmNoRm9ybS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5jYWNoZWRSZXF1ZXN0KHRoaXMudXJsKCkpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGNiICYmIGNiKG51bGwsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBjYiAmJiBjYihlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZWFyY2hGb3JtO1xyXG59KCkpO1xuXG52YXIgT1BFUkFUT1IgPSB7XHJcbiAgICBhdDogJ2F0JyxcclxuICAgIG5vdDogJ25vdCcsXHJcbiAgICBtaXNzaW5nOiAnbWlzc2luZycsXHJcbiAgICBoYXM6ICdoYXMnLFxyXG4gICAgYW55OiAnYW55JyxcclxuICAgIGluOiAnaW4nLFxyXG4gICAgZnVsbHRleHQ6ICdmdWxsdGV4dCcsXHJcbiAgICBzaW1pbGFyOiAnc2ltaWxhcicsXHJcbiAgICBudW1iZXJHdDogJ251bWJlci5ndCcsXHJcbiAgICBudW1iZXJMdDogJ251bWJlci5sdCcsXHJcbiAgICBudW1iZXJJblJhbmdlOiAnbnVtYmVyLmluUmFuZ2UnLFxyXG4gICAgZGF0ZUJlZm9yZTogJ2RhdGUuYmVmb3JlJyxcclxuICAgIGRhdGVBZnRlcjogJ2RhdGUuYWZ0ZXInLFxyXG4gICAgZGF0ZUJldHdlZW46ICdkYXRlLmJldHdlZW4nLFxyXG4gICAgZGF0ZURheU9mTW9udGg6ICdkYXRlLmRheS1vZi1tb250aCcsXHJcbiAgICBkYXRlRGF5T2ZNb250aEFmdGVyOiAnZGF0ZS5kYXktb2YtbW9udGgtYWZ0ZXInLFxyXG4gICAgZGF0ZURheU9mTW9udGhCZWZvcmU6ICdkYXRlLmRheS1vZi1tb250aC1iZWZvcmUnLFxyXG4gICAgZGF0ZURheU9mV2VlazogJ2RhdGUuZGF5LW9mLXdlZWsnLFxyXG4gICAgZGF0ZURheU9mV2Vla0FmdGVyOiAnZGF0ZS5kYXktb2Ytd2Vlay1hZnRlcicsXHJcbiAgICBkYXRlRGF5T2ZXZWVrQmVmb3JlOiAnZGF0ZS5kYXktb2Ytd2Vlay1iZWZvcmUnLFxyXG4gICAgZGF0ZU1vbnRoOiAnZGF0ZS5tb250aCcsXHJcbiAgICBkYXRlTW9udGhCZWZvcmU6ICdkYXRlLm1vbnRoLWJlZm9yZScsXHJcbiAgICBkYXRlTW9udGhBZnRlcjogJ2RhdGUubW9udGgtYWZ0ZXInLFxyXG4gICAgZGF0ZVllYXI6ICdkYXRlLnllYXInLFxyXG4gICAgZGF0ZUhvdXI6ICdkYXRlLmhvdXInLFxyXG4gICAgZGF0ZUhvdXJCZWZvcmU6ICdkYXRlLmhvdXItYmVmb3JlJyxcclxuICAgIGRhdGVIb3VyQWZ0ZXI6ICdkYXRlLmhvdXItYWZ0ZXInLFxyXG4gICAgR2VvcG9pbnROZWFyOiAnZ2VvcG9pbnQubmVhcicsXHJcbn07XHJcbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGVuY29kZSh2KTsgfSkuam9pbignLCcpICsgXCJdXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZW5jb2RlIFwiICsgdmFsdWUgKyBcIiBvZiB0eXBlIFwiICsgdHlwZW9mIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG52YXIgZ2VvcG9pbnQgPSB7XHJcbiAgICBuZWFyOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHJhZGl1cykge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLkdlb3BvaW50TmVhciArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBsYXRpdHVkZSArIFwiLCBcIiArIGxvbmdpdHVkZSArIFwiLCBcIiArIHJhZGl1cyArIFwiKV1cIjtcclxuICAgIH0sXHJcbn07XHJcbnZhciBkYXRlID0ge1xyXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGJlZm9yZSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVCZWZvcmUgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZW5jb2RlKGJlZm9yZSkgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIChmcmFnbWVudCwgYWZ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlQWZ0ZXIgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZW5jb2RlKGFmdGVyKSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBiZXR3ZWVuOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGJlZm9yZSwgYWZ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlQmV0d2VlbiArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUoYmVmb3JlKSArIFwiLCBcIiArIGVuY29kZShhZnRlcikgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aDogZnVuY3Rpb24gKGZyYWdtZW50LCBkYXkpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlRGF5T2ZNb250aCArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBkYXkgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aEFmdGVyOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGRheSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVEYXlPZk1vbnRoQWZ0ZXIgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZGF5ICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhCZWZvcmU6IGZ1bmN0aW9uIChmcmFnbWVudCwgZGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT1BFUkFUT1IuZGF0ZURheU9mTW9udGhCZWZvcmUgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZGF5ICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGRheU9mV2VlazogZnVuY3Rpb24gKGZyYWdtZW50LCBkYXkpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlRGF5T2ZXZWVrICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGVuY29kZShkYXkpICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGRheU9mV2Vla0FmdGVyOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGRheSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVEYXlPZldlZWtBZnRlciArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUoZGF5KSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBkYXlPZldlZWtCZWZvcmU6IGZ1bmN0aW9uIChmcmFnbWVudCwgZGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT1BFUkFUT1IuZGF0ZURheU9mV2Vla0JlZm9yZSArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUoZGF5KSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBtb250aDogZnVuY3Rpb24gKGZyYWdtZW50LCBtb250aCkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVNb250aCArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUobW9udGgpICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIG1vbnRoQmVmb3JlOiBmdW5jdGlvbiAoZnJhZ21lbnQsIG1vbnRoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT1BFUkFUT1IuZGF0ZU1vbnRoQmVmb3JlICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGVuY29kZShtb250aCkgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgbW9udGhBZnRlcjogZnVuY3Rpb24gKGZyYWdtZW50LCBtb250aCkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVNb250aEFmdGVyICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGVuY29kZShtb250aCkgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgeWVhcjogZnVuY3Rpb24gKGZyYWdtZW50LCB5ZWFyKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT1BFUkFUT1IuZGF0ZVllYXIgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgeWVhciArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBob3VyOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGhvdXIpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlSG91ciArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBob3VyICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGhvdXJCZWZvcmU6IGZ1bmN0aW9uIChmcmFnbWVudCwgaG91cikge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmRhdGVIb3VyQmVmb3JlICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGhvdXIgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgaG91ckFmdGVyOiBmdW5jdGlvbiAoZnJhZ21lbnQsIGhvdXIpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5kYXRlSG91ckFmdGVyICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGhvdXIgKyBcIildXCI7XHJcbiAgICB9LFxyXG59O1xyXG52YXIgbnVtYmVyID0ge1xyXG4gICAgZ3Q6IGZ1bmN0aW9uIChmcmFnbWVudCwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5udW1iZXJHdCArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyB2YWx1ZSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBsdDogZnVuY3Rpb24gKGZyYWdtZW50LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLm51bWJlckx0ICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIHZhbHVlICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGluUmFuZ2U6IGZ1bmN0aW9uIChmcmFnbWVudCwgYmVmb3JlLCBhZnRlcikge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLm51bWJlckluUmFuZ2UgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgYmVmb3JlICsgXCIsIFwiICsgYWZ0ZXIgKyBcIildXCI7XHJcbiAgICB9LFxyXG59O1xyXG52YXIgUHJlZGljYXRlcyA9IHtcclxuICAgIGF0OiBmdW5jdGlvbiAoZnJhZ21lbnQsIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgT1BFUkFUT1IuYXQgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZW5jb2RlKHZhbHVlKSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBub3Q6IGZ1bmN0aW9uIChmcmFnbWVudCwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5ub3QgKyBcIihcIiArIGZyYWdtZW50ICsgXCIsIFwiICsgZW5jb2RlKHZhbHVlKSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBtaXNzaW5nOiBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5taXNzaW5nICsgXCIoXCIgKyBmcmFnbWVudCArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBoYXM6IGZ1bmN0aW9uIChmcmFnbWVudCkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmhhcyArIFwiKFwiICsgZnJhZ21lbnQgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgYW55OiBmdW5jdGlvbiAoZnJhZ21lbnQsIHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmFueSArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUodmFsdWVzKSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBpbjogZnVuY3Rpb24gKGZyYWdtZW50LCB2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5pbiArIFwiKFwiICsgZnJhZ21lbnQgKyBcIiwgXCIgKyBlbmNvZGUodmFsdWVzKSArIFwiKV1cIjtcclxuICAgIH0sXHJcbiAgICBmdWxsdGV4dDogZnVuY3Rpb24gKGZyYWdtZW50LCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIE9QRVJBVE9SLmZ1bGx0ZXh0ICsgXCIoXCIgKyBmcmFnbWVudCArIFwiLCBcIiArIGVuY29kZSh2YWx1ZSkgKyBcIildXCI7XHJcbiAgICB9LFxyXG4gICAgc2ltaWxhcjogZnVuY3Rpb24gKGRvY3VtZW50SWQsIG1heFJlc3VsdHMpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBPUEVSQVRPUi5zaW1pbGFyICsgXCIoXFxcIlwiICsgZG9jdW1lbnRJZCArIFwiXFxcIiwgXCIgKyBtYXhSZXN1bHRzICsgXCIpXVwiO1xyXG4gICAgfSxcclxuICAgIGRhdGU6IGRhdGUsXHJcbiAgICBkYXRlQmVmb3JlOiBkYXRlLmJlZm9yZSxcclxuICAgIGRhdGVBZnRlcjogZGF0ZS5hZnRlcixcclxuICAgIGRhdGVCZXR3ZWVuOiBkYXRlLmJldHdlZW4sXHJcbiAgICBkYXlPZk1vbnRoOiBkYXRlLmRheU9mTW9udGgsXHJcbiAgICBkYXlPZk1vbnRoQWZ0ZXI6IGRhdGUuZGF5T2ZNb250aEFmdGVyLFxyXG4gICAgZGF5T2ZNb250aEJlZm9yZTogZGF0ZS5kYXlPZk1vbnRoQmVmb3JlLFxyXG4gICAgZGF5T2ZXZWVrOiBkYXRlLmRheU9mV2VlayxcclxuICAgIGRheU9mV2Vla0FmdGVyOiBkYXRlLmRheU9mV2Vla0FmdGVyLFxyXG4gICAgZGF5T2ZXZWVrQmVmb3JlOiBkYXRlLmRheU9mV2Vla0JlZm9yZSxcclxuICAgIG1vbnRoOiBkYXRlLm1vbnRoLFxyXG4gICAgbW9udGhCZWZvcmU6IGRhdGUubW9udGhCZWZvcmUsXHJcbiAgICBtb250aEFmdGVyOiBkYXRlLm1vbnRoQWZ0ZXIsXHJcbiAgICB5ZWFyOiBkYXRlLnllYXIsXHJcbiAgICBob3VyOiBkYXRlLmhvdXIsXHJcbiAgICBob3VyQmVmb3JlOiBkYXRlLmhvdXJCZWZvcmUsXHJcbiAgICBob3VyQWZ0ZXI6IGRhdGUuaG91ckFmdGVyLFxyXG4gICAgbnVtYmVyOiBudW1iZXIsXHJcbiAgICBndDogbnVtYmVyLmd0LFxyXG4gICAgbHQ6IG51bWJlci5sdCxcclxuICAgIGluUmFuZ2U6IG51bWJlci5pblJhbmdlLFxyXG4gICAgbmVhcjogZ2VvcG9pbnQubmVhcixcclxuICAgIGdlb3BvaW50OiBnZW9wb2ludCxcclxufTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuLy8gU29tZSBwb3J0aW9ucyBvZiBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzaHR0cC9jb29raWVcclxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcclxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0ciwgZGVjb2RlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGUoc3RyKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0ciBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgb2JqID0ge307XHJcbiAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBwYWlycyA9IHN0ci5zcGxpdCgvOyAqLyk7XHJcbiAgICB2YXIgZGVjID0gb3B0LmRlY29kZSB8fCBkZWNvZGU7XHJcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XHJcbiAgICAgICAgdmFyIGVxX2lkeCA9IHBhaXIuaW5kZXhPZignPScpO1xyXG4gICAgICAgIC8vIHNraXAgdGhpbmdzIHRoYXQgZG9uJ3QgbG9vayBsaWtlIGtleT12YWx1ZVxyXG4gICAgICAgIGlmIChlcV9pZHggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IHBhaXIuc3Vic3RyKDAsIGVxX2lkeCkudHJpbSgpO1xyXG4gICAgICAgIHZhciB2YWwgPSBwYWlyLnN1YnN0cigrK2VxX2lkeCwgcGFpci5sZW5ndGgpLnRyaW0oKTtcclxuICAgICAgICAvLyBxdW90ZWQgdmFsdWVzXHJcbiAgICAgICAgaWYgKCdcIicgPT0gdmFsWzBdKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9ubHkgYXNzaWduIG9uY2VcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09IG9ialtrZXldKSB7XHJcbiAgICAgICAgICAgIG9ialtrZXldID0gdHJ5RGVjb2RlKHZhbCwgZGVjKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxudmFyIENvb2tpZXMgPSB7IHBhcnNlOiBwYXJzZSB9O1xuXG5mdW5jdGlvbiBjcmVhdGVQcmV2aWV3UmVzb2x2ZXIodG9rZW4sIGRvY3VtZW50SWQsIGdldERvY0J5SUQpIHtcclxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKGxpbmtSZXNvbHZlciwgZGVmYXVsdFVybCwgY2IpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRJZCAmJiBnZXREb2NCeUlEKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXREb2NCeUlEKGRvY3VtZW50SWQsIHsgcmVmOiB0b2tlbiB9KS50aGVuKGZ1bmN0aW9uIChkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKG51bGwsIGRlZmF1bHRVcmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IChsaW5rUmVzb2x2ZXIgJiYgbGlua1Jlc29sdmVyKGRvY3VtZW50KSkgfHwgZG9jdW1lbnQudXJsIHx8IGRlZmF1bHRVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IobnVsbCwgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVmYXVsdFVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiB7IHRva2VuOiB0b2tlbiwgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCwgcmVzb2x2ZTogcmVzb2x2ZSB9O1xyXG59XG5cbnZhciBQUkVWSUVXX0NPT0tJRSA9ICdpby5wcmlzbWljLnByZXZpZXcnO1xyXG52YXIgRVhQRVJJTUVOVF9DT09LSUUgPSAnaW8ucHJpc21pYy5leHBlcmltZW50JztcclxudmFyIFJlc29sdmVkQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVzb2x2ZWRBcGkoZGF0YSwgaHR0cENsaWVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5tYXN0ZXJSZWYgPSBkYXRhLnJlZnMuZmlsdGVyKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi5pc01hc3RlclJlZjsgfSlbMF07XHJcbiAgICAgICAgdGhpcy5leHBlcmltZW50cyA9IG5ldyBFeHBlcmltZW50cyhkYXRhLmV4cGVyaW1lbnRzKTtcclxuICAgICAgICB0aGlzLmJvb2ttYXJrcyA9IGRhdGEuYm9va21hcmtzO1xyXG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnJlZnMgPSBkYXRhLnJlZnM7XHJcbiAgICAgICAgdGhpcy50YWdzID0gZGF0YS50YWdzO1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSBkYXRhLnR5cGVzO1xyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2VzID0gZGF0YS5sYW5ndWFnZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB1c2VhYmxlIGZvcm0gZnJvbSBpdHMgaWQsIGFzIGRlc2NyaWJlZCBpbiB0aGUgUkVTVGZ1bCBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJLlxyXG4gICAgICogRm9yIGluc3RhbmNlOiBhcGkuZm9ybShcImV2ZXJ5dGhpbmdcIikgd29ya3Mgb24gZXZlcnkgcmVwb3NpdG9yeSAoYXMgXCJldmVyeXRoaW5nXCIgZXhpc3RzIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBZb3UgY2FuIHRoZW4gY2hhaW4gdGhlIGNhbGxzOiBhcGkuZm9ybShcImV2ZXJ5dGhpbmdcIikucXVlcnkoJ1tbOmQgPSBhdChkb2N1bWVudC5pZCwgXCJVa0wwZ011dnpZVUFOQ3BmXCIpXV0nKS5yZWYocmVmKS5zdWJtaXQoKVxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZm9ybSA9IGZ1bmN0aW9uIChmb3JtSWQpIHtcclxuICAgICAgICB2YXIgZm9ybSA9IHRoaXMuZGF0YS5mb3Jtc1tmb3JtSWRdO1xyXG4gICAgICAgIGlmIChmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VhcmNoRm9ybShmb3JtLCB0aGlzLmh0dHBDbGllbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZXZlcnl0aGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZiA9IHRoaXMuZm9ybSgnZXZlcnl0aGluZycpO1xyXG4gICAgICAgIGlmICghZilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGV2ZXJ5dGhpbmcgZm9ybScpO1xyXG4gICAgICAgIHJldHVybiBmO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIElEIG9mIHRoZSBtYXN0ZXIgcmVmIG9uIHRoaXMgcHJpc21pYy5pbyBBUEkuXHJcbiAgICAgKiBEbyBub3QgdXNlIGxpa2UgdGhpczogc2VhcmNoRm9ybS5yZWYoYXBpLm1hc3RlcigpKS5cclxuICAgICAqIEluc3RlYWQsIHNldCB5b3VyIHJlZiBvbmNlIGluIGEgdmFyaWFibGUsIGFuZCBjYWxsIGl0IHdoZW4geW91IG5lZWQgaXQ7IHRoaXMgd2lsbCBhbGxvdyB0byBjaGFuZ2UgdGhlIHJlZiB5b3UncmUgdmlld2luZyBlYXNpbHkgZm9yIHlvdXIgZW50aXJlIHBhZ2UuXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVkQXBpLnByb3RvdHlwZS5tYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUmVmLnJlZjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlZiBJRCBmb3IgYSBnaXZlbiByZWYncyBsYWJlbC5cclxuICAgICAqIERvIG5vdCB1c2UgbGlrZSB0aGlzOiBzZWFyY2hGb3JtLnJlZihhcGkucmVmKFwiRnV0dXJlIHJlbGVhc2UgbGFiZWxcIikpLlxyXG4gICAgICogSW5zdGVhZCwgc2V0IHlvdXIgcmVmIG9uY2UgaW4gYSB2YXJpYWJsZSwgYW5kIGNhbGwgaXQgd2hlbiB5b3UgbmVlZCBpdDsgdGhpcyB3aWxsIGFsbG93IHRvIGNoYW5nZSB0aGUgcmVmIHlvdSdyZSB2aWV3aW5nIGVhc2lseSBmb3IgeW91ciBlbnRpcmUgcGFnZS5cclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZWRBcGkucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzLmRhdGEucmVmcy5maWx0ZXIoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLmxhYmVsID09PSBsYWJlbDsgfSlbMF07XHJcbiAgICAgICAgcmV0dXJuIHJlZiA/IHJlZi5yZWYgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIFJlc29sdmVkQXBpLnByb3RvdHlwZS5jdXJyZW50RXhwZXJpbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHBlcmltZW50cy5jdXJyZW50KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBRdWVyeSB0aGUgcmVwb3NpdG9yeVxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocSwgb3B0aW9uc09yQ2FsbGJhY2ssIGNiKSB7XHJcbiAgICAgICAgaWYgKGNiID09PSB2b2lkIDApIHsgY2IgPSBmdW5jdGlvbiAoKSB7IH07IH1cclxuICAgICAgICB2YXIgX2EgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyB7IG9wdGlvbnM6IHt9LCBjYWxsYmFjazogb3B0aW9uc09yQ2FsbGJhY2sgfVxyXG4gICAgICAgICAgICA6IHsgb3B0aW9uczogb3B0aW9uc09yQ2FsbGJhY2sgfHwge30sIGNhbGxiYWNrOiBjYiB9LCBvcHRpb25zID0gX2Eub3B0aW9ucywgY2FsbGJhY2sgPSBfYS5jYWxsYmFjaztcclxuICAgICAgICB2YXIgZm9ybSA9IHRoaXMuZXZlcnl0aGluZygpO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvcm0gPSBmb3JtLnNldChrZXksIG9wdGlvbnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3B0aW9ucy5yZWYpIHtcclxuICAgICAgICAgICAgLy8gTG9vayBpbiBjb29raWVzIGlmIHdlIGhhdmUgYSByZWYgKHByZXZpZXcgb3IgZXhwZXJpbWVudClcclxuICAgICAgICAgICAgdmFyIGNvb2tpZVN0cmluZyA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcSkgeyAvLyBOb2RlSlNcclxuICAgICAgICAgICAgICAgIGNvb2tpZVN0cmluZyA9IHRoaXMub3B0aW9ucy5yZXEuaGVhZGVyc1snY29va2llJ10gfHwgJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50KSB7IC8vIEJyb3dzZXJcclxuICAgICAgICAgICAgICAgIGNvb2tpZVN0cmluZyA9IHdpbmRvdy5kb2N1bWVudC5jb29raWUgfHwgJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvb2tpZXMgPSBDb29raWVzLnBhcnNlKGNvb2tpZVN0cmluZyk7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aWV3UmVmID0gY29va2llc1tQUkVWSUVXX0NPT0tJRV07XHJcbiAgICAgICAgICAgIHZhciBleHBlcmltZW50UmVmID0gdGhpcy5leHBlcmltZW50cy5yZWZGcm9tQ29va2llKGNvb2tpZXNbRVhQRVJJTUVOVF9DT09LSUVdKTtcclxuICAgICAgICAgICAgZm9ybSA9IGZvcm0ucmVmKHByZXZpZXdSZWYgfHwgZXhwZXJpbWVudFJlZiB8fCB0aGlzLm1hc3RlclJlZi5yZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocSkge1xyXG4gICAgICAgICAgICBmb3JtLnF1ZXJ5KHEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybS5zdWJtaXQoY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGRvY3VtZW50IHJldHVybmVkIGJ5IHRoZSBnaXZlbiBxdWVyeVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl8UHJlZGljYXRlfSB0aGUgcXVlcnlcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEluIE5vZGVKUywgcGFzcyB0aGUgcmVxdWVzdCBhcyAncmVxJy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrKGVyciwgZG9jKVxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUucXVlcnlGaXJzdCA9IGZ1bmN0aW9uIChxLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcclxuICAgICAgICB2YXIgX2EgPSB0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgPyB7IG9wdGlvbnM6IHt9LCBjYWxsYmFjazogb3B0aW9uc09yQ2FsbGJhY2sgfVxyXG4gICAgICAgICAgICA6IHsgb3B0aW9uczogb3B0aW9uc09yQ2FsbGJhY2sgfHwge30sIGNhbGxiYWNrOiBjYiB8fCAoZnVuY3Rpb24gKCkgeyB9KSB9LCBvcHRpb25zID0gX2Eub3B0aW9ucywgY2FsbGJhY2sgPSBfYS5jYWxsYmFjaztcclxuICAgICAgICBvcHRpb25zLnBhZ2UgPSAxO1xyXG4gICAgICAgIG9wdGlvbnMucGFnZVNpemUgPSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHEsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLnJlc3VsdHMgJiYgcmVzcG9uc2UucmVzdWx0c1swXTtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gaWRcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZWRBcGkucHJvdG90eXBlLmdldEJ5SUQgPSBmdW5jdGlvbiAoaWQsIG1heWJlT3B0aW9ucywgY2IpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IG1heWJlT3B0aW9ucyA/IF9fYXNzaWduKHt9LCBtYXliZU9wdGlvbnMpIDoge307XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmxhbmcpXHJcbiAgICAgICAgICAgIG9wdGlvbnMubGFuZyA9ICcqJztcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUZpcnN0KFByZWRpY2F0ZXMuYXQoJ2RvY3VtZW50LmlkJywgaWQpLCBvcHRpb25zLCBjYik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBtdWx0aXBsZSBkb2N1bWVudHMgZnJvbSBhbiBhcnJheSBvZiBpZFxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZ2V0QnlJRHMgPSBmdW5jdGlvbiAoaWRzLCBtYXliZU9wdGlvbnMsIGNiKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBtYXliZU9wdGlvbnMgPyBfX2Fzc2lnbih7fSwgbWF5YmVPcHRpb25zKSA6IHt9O1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5sYW5nKVxyXG4gICAgICAgICAgICBvcHRpb25zLmxhbmcgPSAnKic7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnkoUHJlZGljYXRlcy5pbignZG9jdW1lbnQuaWQnLCBpZHMpLCBvcHRpb25zLCBjYik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gdWlkXHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVkQXBpLnByb3RvdHlwZS5nZXRCeVVJRCA9IGZ1bmN0aW9uICh0eXBlLCB1aWQsIG1heWJlT3B0aW9ucywgY2IpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IG1heWJlT3B0aW9ucyA/IF9fYXNzaWduKHt9LCBtYXliZU9wdGlvbnMpIDoge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGFuZyA9PT0gJyonKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGT1JCSURERU4uIFlvdSBjYW4ndCB1c2UgZ2V0QnlVSUQgd2l0aCAqLCB1c2UgdGhlIHByZWRpY2F0ZXMgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnBhZ2UpXHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFnZSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlGaXJzdChQcmVkaWNhdGVzLmF0KFwibXkuXCIgKyB0eXBlICsgXCIudWlkXCIsIHVpZCksIG9wdGlvbnMsIGNiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBzaW5nbGV0b24gZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gdHlwZVxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZ2V0U2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG1heWJlT3B0aW9ucywgY2IpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IG1heWJlT3B0aW9ucyA/IF9fYXNzaWduKHt9LCBtYXliZU9wdGlvbnMpIDoge307XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlGaXJzdChQcmVkaWNhdGVzLmF0KCdkb2N1bWVudC50eXBlJywgdHlwZSksIG9wdGlvbnMsIGNiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBib29rbWFya1xyXG4gICAgICovXHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiAoYm9va21hcmssIG1heWJlT3B0aW9ucywgY2IpIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmRhdGEuYm9va21hcmtzW2Jvb2ttYXJrXTtcclxuICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnlJRChpZCwgbWF5YmVPcHRpb25zLCBjYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Vycm9yIHJldHJpZXZpbmcgYm9va21hcmtlZCBpZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXNvbHZlZEFwaS5wcm90b3R5cGUuZ2V0UHJldmlld1Jlc29sdmVyID0gZnVuY3Rpb24gKHRva2VuLCBkb2N1bWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVByZXZpZXdSZXNvbHZlcih0b2tlbiwgZG9jdW1lbnRJZCwgdGhpcy5nZXRCeUlELmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNvbHZlZEFwaTtcclxufSgpKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuLyoqXHJcbiogQSBkb3VibHkgbGlua2VkIGxpc3QtYmFzZWQgTGVhc3QgUmVjZW50bHkgVXNlZCAoTFJVKSBjYWNoZS4gV2lsbCBrZWVwIG1vc3RcclxuKiByZWNlbnRseSB1c2VkIGl0ZW1zIHdoaWxlIGRpc2NhcmRpbmcgbGVhc3QgcmVjZW50bHkgdXNlZCBpdGVtcyB3aGVuIGl0cyBsaW1pdFxyXG4qIGlzIHJlYWNoZWQuXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciBNSVQuIENvcHlyaWdodCAoYykgMjAxMCBSYXNtdXMgQW5kZXJzc29uIDxodHRwOi8vaHVuY2guc2UvPlxyXG4qIFR5cGVzY3JpcHQtaWZpZWQgYnkgT2xla3NhbmRyIE5pa2l0aW4gPGh0dHBzOi8vdHZvcmkuaW5mbz5cclxuKlxyXG4qIElsbHVzdHJhdGlvbiBvZiB0aGUgZGVzaWduOlxyXG4qXHJcbiogICAgICAgZW50cnkgICAgICAgICAgICAgZW50cnkgICAgICAgICAgICAgZW50cnkgICAgICAgICAgICAgZW50cnlcclxuKiAgICAgICBfX19fX18gICAgICAgICAgICBfX19fX18gICAgICAgICAgICBfX19fX18gICAgICAgICAgICBfX19fX19cclxuKiAgICAgIHwgaGVhZCB8Lm5ld2VyID0+IHwgICAgICB8Lm5ld2VyID0+IHwgICAgICB8Lm5ld2VyID0+IHwgdGFpbCB8XHJcbiogICAgICB8ICBBICAgfCAgICAgICAgICB8ICBCICAgfCAgICAgICAgICB8ICBDICAgfCAgICAgICAgICB8ICBEICAgfFxyXG4qICAgICAgfF9fX19fX3wgPD0gb2xkZXIufF9fX19fX3wgPD0gb2xkZXIufF9fX19fX3wgPD0gb2xkZXIufF9fX19fX3xcclxuKlxyXG4qICByZW1vdmVkICA8LS0gIDwtLSAgPC0tICA8LS0gIDwtLSAgPC0tICA8LS0gIDwtLSAgPC0tICA8LS0gIDwtLSAgYWRkZWRcclxuKi9cclxuZnVuY3Rpb24gTWFrZUxSVUNhY2hlKGxpbWl0KSB7XHJcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKGxpbWl0KTtcclxufVxyXG5mdW5jdGlvbiBMUlVDYWNoZShsaW1pdCkge1xyXG4gICAgLy8gQ3VycmVudCBzaXplIG9mIHRoZSBjYWNoZS4gKFJlYWQtb25seSkuXHJcbiAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdGhpcyBjYWNoZSBjYW4gaG9sZC5cclxuICAgIHRoaXMubGltaXQgPSBsaW1pdDtcclxuICAgIHRoaXMuX2tleW1hcCA9IHt9O1xyXG59XHJcbi8qKlxyXG4gKiBQdXQgPHZhbHVlPiBpbnRvIHRoZSBjYWNoZSBhc3NvY2lhdGVkIHdpdGggPGtleT4uIFJldHVybnMgdGhlIGVudHJ5IHdoaWNoIHdhc1xyXG4gKiByZW1vdmVkIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxyXG4gKiAoaS5lLiBpZiB0aGVyZSB3YXMgZW5vdWdoIHJvb20gYWxyZWFkeSkuXHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgIHZhciBlbnRyeSA9IHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xyXG4gICAgLy8gTm90ZTogTm8gcHJvdGVjdGlvbiBhZ2FpbnMgcmVwbGFjaW5nLCBhbmQgdGh1cyBvcnBoYW4gZW50cmllcy4gQnkgZGVzaWduLlxyXG4gICAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeTtcclxuICAgIGlmICh0aGlzLnRhaWwpIHtcclxuICAgICAgICAvLyBsaW5rIHByZXZpb3VzIHRhaWwgdG8gdGhlIG5ldyB0YWlsIChlbnRyeSlcclxuICAgICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTtcclxuICAgICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHdlJ3JlIGZpcnN0IGluIC0tIHlheVxyXG4gICAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xyXG4gICAgfVxyXG4gICAgLy8gYWRkIG5ldyBlbnRyeSB0byB0aGUgZW5kIG9mIHRoZSBsaW5rZWQgbGlzdCAtLSBpdCdzIG5vdyB0aGUgZnJlc2hlc3QgZW50cnkuXHJcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcclxuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcclxuICAgICAgICAvLyB3ZSBoaXQgdGhlIGxpbWl0IC0tIHJlbW92ZSB0aGUgaGVhZFxyXG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2l6ZSBjb3VudGVyXHJcbiAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBQdXJnZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBmcm9tIHRoZSBjYWNoZS4gUmV0dXJucyB0aGVcclxuICogcmVtb3ZlZCBlbnRyeSBvciB1bmRlZmluZWQgaWYgdGhlIGNhY2hlIHdhcyBlbXB0eS5cclxuICpcclxuICogSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBhbnkgZm9ybSBvZiBmaW5hbGl6YXRpb24gb2YgcHVyZ2VkIGl0ZW1zLCB0aGlzIGlzIGFcclxuICogZ29vZCBwbGFjZSB0byBkbyBpdC4gU2ltcGx5IG92ZXJyaWRlL3JlcGxhY2UgdGhpcyBmdW5jdGlvbjpcclxuICpcclxuICogICB2YXIgYyA9IG5ldyBMUlVDYWNoZSgxMjMpO1xyXG4gKiAgIGMuc2hpZnQgPSBmdW5jdGlvbigpIHtcclxuICogICAgIHZhciBlbnRyeSA9IExSVUNhY2hlLnByb3RvdHlwZS5zaGlmdC5jYWxsKHRoaXMpO1xyXG4gKiAgICAgZG9Tb21ldGhpbmdXaXRoKGVudHJ5KTtcclxuICogICAgIHJldHVybiBlbnRyeTtcclxuICogICB9XHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyB0b2RvOiBoYW5kbGUgc3BlY2lhbCBjYXNlIHdoZW4gbGltaXQgPT0gMVxyXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkO1xyXG4gICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZC5uZXdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZC5vbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxhc3Qgc3Ryb25nIHJlZmVyZW5jZSB0byA8ZW50cnk+IGFuZCByZW1vdmUgbGlua3MgZnJvbSB0aGUgcHVyZ2VkXHJcbiAgICAgICAgLy8gZW50cnkgYmVpbmcgcmV0dXJuZWQ6XHJcbiAgICAgICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBkZWxldGUgaXMgc2xvdywgYnV0IHdlIG5lZWQgdG8gZG8gdGhpcyB0byBhdm9pZCB1bmNvbnRyb2xsYWJsZSBncm93dGg6XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2tleW1hcFtlbnRyeS5rZXldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ3B1cmdpbmcgJywgZW50cnkua2V5KTtcclxuICAgIHJldHVybiBlbnRyeTtcclxufTtcclxuLyoqXHJcbiAqIEdldCBhbmQgcmVnaXN0ZXIgcmVjZW50IHVzZSBvZiA8a2V5Pi4gUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+XHJcbiAqIG9yIHVuZGVmaW5lZCBpZiBub3QgaW4gY2FjaGUuXHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgcmV0dXJuRW50cnkpIHtcclxuICAgIC8vIEZpcnN0LCBmaW5kIG91ciBjYWNoZSBlbnRyeVxyXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XHJcbiAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm47IC8vIE5vdCBjYWNoZWQuIFNvcnJ5LlxyXG4gICAgLy8gQXMgPGtleT4gd2FzIGZvdW5kIGluIHRoZSBjYWNoZSwgcmVnaXN0ZXIgaXQgYXMgYmVpbmcgcmVxdWVzdGVkIHJlY2VudGx5XHJcbiAgICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xyXG4gICAgICAgIC8vIEFscmVhZHkgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBlbnRyeSwgc28gbm8gbmVlZCB0byB1cGRhdGUgdGhlIGxpc3RcclxuICAgICAgICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gSEVBRC0tLS0tLS0tLS0tLS0tVEFJTFxyXG4gICAgLy8gICA8Lm9sZGVyICAgLm5ld2VyPlxyXG4gICAgLy8gIDwtLS0gYWRkIGRpcmVjdGlvbiAtLVxyXG4gICAgLy8gICBBICBCICBDICA8RD4gIEVcclxuICAgIGlmIChlbnRyeS5uZXdlcikge1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdGhpcy5oZWFkKVxyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlcjtcclxuICAgICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyOyAvLyBDIDwtLSBFLlxyXG4gICAgfVxyXG4gICAgaWYgKGVudHJ5Lm9sZGVyKVxyXG4gICAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7IC8vIEMuIC0tPiBFXHJcbiAgICBlbnRyeS5uZXdlciA9IHVuZGVmaW5lZDsgLy8gRCAtLXhcclxuICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsOyAvLyBELiAtLT4gRVxyXG4gICAgaWYgKHRoaXMudGFpbClcclxuICAgICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTsgLy8gRS4gPC0tIERcclxuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xyXG4gICAgcmV0dXJuIHJldHVybkVudHJ5ID8gZW50cnkgOiBlbnRyeS52YWx1ZTtcclxufTtcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBGb2xsb3dpbmcgY29kZSBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlbW92ZWQgd2l0aG91dCBicmVha2luZyB0aGUgY29yZVxyXG4vLyBmdW5jdGlvbmFsaXR5LlxyXG4vKipcclxuICogQ2hlY2sgaWYgPGtleT4gaXMgaW4gdGhlIGNhY2hlIHdpdGhvdXQgcmVnaXN0ZXJpbmcgcmVjZW50IHVzZS4gRmVhc2libGUgaWZcclxuICogeW91IGRvIG5vdCB3YW50IHRvIGNoYWdlIHRoZSBzdGF0ZSBvZiB0aGUgY2FjaGUsIGJ1dCBvbmx5IFwicGVla1wiIGF0IGl0LlxyXG4gKiBSZXR1cm5zIHRoZSBlbnRyeSBhc3NvY2lhdGVkIHdpdGggPGtleT4gaWYgZm91bmQsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLl9rZXltYXBba2V5XTtcclxufTtcclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgZW50cnkgd2l0aCA8a2V5Pi4gUmV0dXJucyB0aGUgb2xkIHZhbHVlLCBvciB1bmRlZmluZWQgaWZcclxuICogZW50cnkgd2FzIG5vdCBpbiB0aGUgY2FjaGUuXHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgIHZhciBvbGR2YWx1ZTtcclxuICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XHJcbiAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICBvbGR2YWx1ZSA9IGVudHJ5LnZhbHVlO1xyXG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvbGR2YWx1ZSA9IHRoaXMucHV0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIGlmIChvbGR2YWx1ZSlcclxuICAgICAgICAgICAgb2xkdmFsdWUgPSBvbGR2YWx1ZS52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvbGR2YWx1ZTtcclxufTtcclxuLyoqXHJcbiAqIFJlbW92ZSBlbnRyeSA8a2V5PiBmcm9tIGNhY2hlIGFuZCByZXR1cm4gaXRzIHZhbHVlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3RcclxuICogZm91bmQuXHJcbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fa2V5bWFwW2tleV07XHJcbiAgICBpZiAoIWVudHJ5KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRlbGV0ZSB0aGlzLl9rZXltYXBbZW50cnkua2V5XTsgLy8gbmVlZCB0byBkbyBkZWxldGUgdW5mb3J0dW5hdGVseVxyXG4gICAgaWYgKGVudHJ5Lm5ld2VyICYmIGVudHJ5Lm9sZGVyKSB7XHJcbiAgICAgICAgLy8gcmVsaW5rIHRoZSBvbGRlciBlbnRyeSB3aXRoIHRoZSBuZXdlciBlbnRyeVxyXG4gICAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XHJcbiAgICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVudHJ5Lm5ld2VyKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaW5rIHRvIHVzXHJcbiAgICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gbGluayB0aGUgbmV3ZXIgZW50cnkgdG8gaGVhZFxyXG4gICAgICAgIHRoaXMuaGVhZCA9IGVudHJ5Lm5ld2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZW50cnkub2xkZXIpIHtcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGxpbmsgdG8gdXNcclxuICAgICAgICBlbnRyeS5vbGRlci5uZXdlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBsaW5rIHRoZSBuZXdlciBlbnRyeSB0byBoZWFkXHJcbiAgICAgICAgdGhpcy50YWlsID0gZW50cnkub2xkZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHsgLy8gaWYoZW50cnkub2xkZXIgPT09IHVuZGVmaW5lZCAmJiBlbnRyeS5uZXdlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zaXplLS07XHJcbiAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbn07XHJcbi8qKiBSZW1vdmVzIGFsbCBlbnRyaWVzICovXHJcbkxSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBzYWZlLCBhcyB3ZSBuZXZlciBleHBvc2Ugc3Ryb25nIHJlZnJlbmNlcyB0byB0aGUgb3V0c2lkZVxyXG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5zaXplID0gMDtcclxuICAgIHRoaXMuX2tleW1hcCA9IHt9O1xyXG59O1xyXG4vKipcclxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgb2YgZW50cmllcyBzdG9yZWQgaW4gdGhlIGNhY2hlIG9iamVjdCwgaW5cclxuICogYXJiaXRyYXJ5IG9yZGVyLlxyXG4gKi9cclxuaWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9rZXltYXApOyB9O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2tleW1hcClcclxuICAgICAgICAgICAga2V5cy5wdXNoKGspO1xyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ2FsbCBgZnVuYCBmb3IgZWFjaCBlbnRyeS4gU3RhcnRpbmcgd2l0aCB0aGUgbmV3ZXN0IGVudHJ5IGlmIGBkZXNjYCBpcyBhIHRydWVcclxuICogdmFsdWUsIG90aGVyd2lzZSBzdGFydHMgd2l0aCB0aGUgb2xkZXN0IChoZWFkKSBlbnJ0eSBhbmQgbW92ZXMgdG93YXJkcyB0aGVcclxuICogdGFpbC5cclxuICpcclxuICogYGZ1bmAgaXMgY2FsbGVkIHdpdGggMyBhcmd1bWVudHMgaW4gdGhlIGNvbnRleHQgYGNvbnRleHRgOlxyXG4gKiAgIGBmdW4uY2FsbChjb250ZXh0LCBPYmplY3Qga2V5LCBPYmplY3QgdmFsdWUsIExSVUNhY2hlIHNlbGYpYFxyXG4gKi9cclxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuLCBjb250ZXh0LCBkZXNjKSB7XHJcbiAgICB2YXIgZW50cnk7XHJcbiAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGRlc2MgPSB0cnVlO1xyXG4gICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICBpZiAoZGVzYykge1xyXG4gICAgICAgIGVudHJ5ID0gdGhpcy50YWlsO1xyXG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xyXG4gICAgICAgICAgICBmdW4uY2FsbChjb250ZXh0LCBlbnRyeS5rZXksIGVudHJ5LnZhbHVlLCB0aGlzKTtcclxuICAgICAgICAgICAgZW50cnkgPSBlbnRyeS5vbGRlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbnRyeSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAoZW50cnkpIHtcclxuICAgICAgICAgICAgZnVuLmNhbGwoY29udGV4dCwgZW50cnkua2V5LCBlbnRyeS52YWx1ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV3ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKiogUmV0dXJucyBhIEpTT04gKGFycmF5KSByZXByZXNlbnRhdGlvbiAqL1xyXG4vL0xSVUNhY2hlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbi8vICAgIHZhciBzOiBJRW50cnlbXSA9IFtdLCBlbnRyeSA9IHRoaXMuaGVhZDtcclxuLy8gICAgd2hpbGUgKGVudHJ5KSB7XHJcbi8vICAgICAgICBzLnB1c2goeyBrZXk6IGVudHJ5LmtleS50b0pTT04oKSwgdmFsdWU6IGVudHJ5LnZhbHVlLnRvSlNPTigpIH0pO1xyXG4vLyAgICAgICAgZW50cnkgPSBlbnRyeS5uZXdlcjtcclxuLy8gICAgfVxyXG4vLyAgICByZXR1cm4gcztcclxuLy99O1xyXG4vKiogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiAqL1xyXG5MUlVDYWNoZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcyA9ICcnLCBlbnRyeSA9IHRoaXMuaGVhZDtcclxuICAgIHdoaWxlIChlbnRyeSkge1xyXG4gICAgICAgIHMgKz0gU3RyaW5nKGVudHJ5LmtleSkgKyAnOicgKyBlbnRyeS52YWx1ZTtcclxuICAgICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xyXG4gICAgICAgIGlmIChlbnRyeSlcclxuICAgICAgICAgICAgcyArPSAnIDwgJztcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG59O1xyXG4vLyBFeHBvcnQgb3Vyc2VsdmVzXHJcbi8vaWYgKHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JykgdGhpcy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG52YXIgRGVmYXVsdEFwaUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdEFwaUNhY2hlKGxpbWl0KSB7XHJcbiAgICAgICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAxMDAwOyB9XHJcbiAgICAgICAgdGhpcy5scnUgPSBNYWtlTFJVQ2FjaGUobGltaXQpO1xyXG4gICAgfVxyXG4gICAgRGVmYXVsdEFwaUNhY2hlLnByb3RvdHlwZS5pc0V4cGlyZWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5scnUuZ2V0KGtleSwgZmFsc2UpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZXhwaXJlZEluICE9PSAwICYmIHZhbHVlLmV4cGlyZWRJbiA8IERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRBcGlDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY2IpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxydS5nZXQoa2V5LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmlzRXhwaXJlZChrZXkpKSB7XHJcbiAgICAgICAgICAgIGNiKG51bGwsIHZhbHVlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2IgJiYgY2IobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlZmF1bHRBcGlDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHR0bCwgY2IpIHtcclxuICAgICAgICB0aGlzLmxydS5yZW1vdmUoa2V5KTtcclxuICAgICAgICB0aGlzLmxydS5wdXQoa2V5LCB7XHJcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxyXG4gICAgICAgICAgICBleHBpcmVkSW46IHR0bCA/IChEYXRlLm5vdygpICsgKHR0bCAqIDEwMDApKSA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2IgJiYgY2IobnVsbCk7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEFwaUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBjYikge1xyXG4gICAgICAgIHRoaXMubHJ1LnJlbW92ZShrZXkpO1xyXG4gICAgICAgIGNiICYmIGNiKG51bGwpO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRBcGlDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICB0aGlzLmxydS5yZW1vdmVBbGwoKTtcclxuICAgICAgICBjYiAmJiBjYihudWxsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdEFwaUNhY2hlO1xyXG59KCkpO1xuXG5mdW5jdGlvbiBmZXRjaFJlcXVlc3QodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGZldGNoT3B0aW9ucyA9IHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm94eUFnZW50KSB7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmFnZW50ID0gb3B0aW9ucy5wcm94eUFnZW50O1xyXG4gICAgfVxyXG4gICAgLy8gY2FuJ3QgdXNlIG51bWJlciBiZWNhdXNlIG9mIE5vZGVKUyBnbG9iYWxzIGluY2x1ZGVkXHJcbiAgICB2YXIgdGltZW91dElkO1xyXG4gICAgdmFyIGZldGNoUHJvbWlzZSA9IGNyb3NzRmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xyXG4gICAgdmFyIHByb21pc2UgPSBvcHRpb25zLnRpbWVvdXRJbk1zID8gUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICBmZXRjaFByb21pc2UsXHJcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IodXJsICsgXCIgcmVzcG9uc2UgdGltZW91dFwiKSk7IH0sIG9wdGlvbnMudGltZW91dEluTXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICBdKSA6IGZldGNoUHJvbWlzZTtcclxuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgIGlmICh+fihyZXNwLnN0YXR1cyAvIDEwMCAhPT0gMikpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgKiBkcmFpbiB0aGUgcmVzcCBiZWZvcmUgdGhyb3dpbmcgYW4gZXJyb3IgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoL2lzc3Vlcy84M1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3AudGV4dCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0YXR1cyBjb2RlIFtcIiArIHJlc3Auc3RhdHVzICsgXCJdIG9uIFVSTCBcIiArIHVybCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0YXR1cyA9IHJlc3Auc3RhdHVzO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwLmpzb24oKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlQ29udHJvbCA9IHJlc3AuaGVhZGVycy5nZXQoJ2NhY2hlLWNvbnRyb2wnKTtcclxuICAgICAgICAgICAgdmFyIHBhcnNlZENhY2hlQ29udHJvbCA9IGNhY2hlQ29udHJvbCA/IC9tYXgtYWdlPShcXGQrKS8uZXhlYyhjYWNoZUNvbnRyb2wpIDogbnVsbDtcclxuICAgICAgICAgICAgdmFyIHR0bCA9IHBhcnNlZENhY2hlQ29udHJvbCA/IHBhcnNlSW50KHBhcnNlZENhY2hlQ29udHJvbFsxXSwgMTApIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQsIHJlc3AsIHR0bCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgIH0pO1xyXG59XHJcbnZhciBEZWZhdWx0UmVxdWVzdEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZWZhdWx0UmVxdWVzdEhhbmRsZXIob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICBEZWZhdWx0UmVxdWVzdEhhbmRsZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGZldGNoUmVxdWVzdCh1cmwsIHRoaXMub3B0aW9ucywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWZhdWx0UmVxdWVzdEhhbmRsZXI7XHJcbn0oKSk7XG5cbnZhciBIdHRwQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSHR0cENsaWVudChyZXF1ZXN0SGFuZGxlciwgY2FjaGUsIHByb3h5QWdlbnQsIHRpbWVvdXRJbk1zKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGFuZGxlciA9IHJlcXVlc3RIYW5kbGVyIHx8IG5ldyBEZWZhdWx0UmVxdWVzdEhhbmRsZXIoeyBwcm94eUFnZW50OiBwcm94eUFnZW50LCB0aW1lb3V0SW5NczogdGltZW91dEluTXMgfSk7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlIHx8IG5ldyBEZWZhdWx0QXBpQ2FjaGUoKTtcclxuICAgIH1cclxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdEhhbmRsZXIucmVxdWVzdCh1cmwsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCwgeGhyLCB0dGwpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXJyLCBudWxsLCB4aHIsIHR0bCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCByZXN1bHQsIHhociwgdHRsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2ggYSBVUkwgY29ycmVzcG9uZGluZyB0byBhIHF1ZXJ5LCBhbmQgcGFyc2UgdGhlIHJlc3BvbnNlIGFzIGEgUmVzcG9uc2Ugb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLmNhY2hlZFJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBtYXliZU9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gbWF5YmVPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBydW4gPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gb3B0aW9ucy5jYWNoZUtleSB8fCB1cmw7XHJcbiAgICAgICAgICAgIF90aGlzLmNhY2hlLmdldChjYWNoZUtleSwgZnVuY3Rpb24gKGNhY2hlR2V0RXJyb3IsIGNhY2hlR2V0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZUdldEVycm9yIHx8IGNhY2hlR2V0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYihjYWNoZUdldEVycm9yLCBjYWNoZUdldFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3QodXJsLCBmdW5jdGlvbiAoZmV0Y2hFcnJvciwgZmV0Y2hWYWx1ZSwgXywgdHRsUmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZXRjaEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihmZXRjaEVycm9yLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dGwgPSB0dGxSZXEgfHwgb3B0aW9ucy50dGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHRsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCBmZXRjaFZhbHVlLCB0dGwsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZldGNoVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgcnVuKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSHR0cENsaWVudDtcclxufSgpKTtcblxuZnVuY3Rpb24gc2VwYXJhdG9yKHVybCkge1xyXG4gICAgcmV0dXJuIHVybC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JztcclxufVxyXG52YXIgQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXBpKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5ncyA9IFtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuICYmIFwiYWNjZXNzX3Rva2VuPVwiICsgdGhpcy5vcHRpb25zLmFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucm91dGVzICYmIFwicm91dGVzPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucy5yb3V0ZXMpKVxyXG4gICAgICAgIF1cclxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcclxuICAgICAgICBpZiAocXVlcnlTdHJpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy51cmwgKz0gc2VwYXJhdG9yKHVybCkgKyBxdWVyeVN0cmluZ3Muam9pbignJicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFwaURhdGFUVEwgPSB0aGlzLm9wdGlvbnMuYXBpRGF0YVRUTCB8fCA1O1xyXG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHRoaXMub3B0aW9ucy5yZXF1ZXN0SGFuZGxlciwgdGhpcy5vcHRpb25zLmFwaUNhY2hlLCB0aGlzLm9wdGlvbnMucHJveHlBZ2VudCwgdGhpcy5vcHRpb25zLnRpbWVvdXRJbk1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBhcGkgY2xpZW50LCBmcm9tIGNhY2hlIGlmIGl0J3NcclxuICAgICAqIHByZXNlbnQsIG90aGVyd2lzZSBmcm9tIGNhbGxpbmcgdGhlIHByaXNtaWMgYXBpIGVuZHBvaW50ICh3aGljaCBpc1xyXG4gICAgICogdGhlbiBjYWNoZWQpLlxyXG4gICAgICovXHJcbiAgICBBcGkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5jYWNoZWRSZXF1ZXN0KHRoaXMudXJsLCB7IHR0bDogdGhpcy5hcGlEYXRhVFRMIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVkQXBpID0gbmV3IFJlc29sdmVkQXBpKGRhdGEsIF90aGlzLmh0dHBDbGllbnQsIF90aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjYiAmJiBjYihudWxsLCByZXNvbHZlZEFwaSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFwaTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY2IgJiYgY2IoZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXBpO1xyXG59KCkpO1xuXG52YXIgRGVmYXVsdENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRDbGllbnQodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5hcGkgPSBuZXcgQXBpKHVybCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5nZXRBcGkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdldCgpO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRDbGllbnQucHJvdG90eXBlLmV2ZXJ5dGhpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybSgnZXZlcnl0aGluZycpO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRDbGllbnQucHJvdG90eXBlLmZvcm0gPSBmdW5jdGlvbiAoZm9ybUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5U2VhcmNoRm9ybShmb3JtSWQsIHRoaXMuYXBpKTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChxLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGFwaS5xdWVyeShxLCBvcHRpb25zT3JDYWxsYmFjaywgY2IpOyB9KTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5xdWVyeUZpcnN0ID0gZnVuY3Rpb24gKHEsIG9wdGlvbnNPckNhbGxiYWNrLCBjYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEFwaSgpLnRoZW4oZnVuY3Rpb24gKGFwaSkgeyByZXR1cm4gYXBpLnF1ZXJ5Rmlyc3QocSwgb3B0aW9uc09yQ2FsbGJhY2ssIGNiKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdENsaWVudC5wcm90b3R5cGUuZ2V0QnlJRCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucywgY2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGFwaS5nZXRCeUlEKGlkLCBvcHRpb25zLCBjYik7IH0pO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRDbGllbnQucHJvdG90eXBlLmdldEJ5SURzID0gZnVuY3Rpb24gKGlkcywgb3B0aW9ucywgY2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGFwaS5nZXRCeUlEcyhpZHMsIG9wdGlvbnMsIGNiKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdENsaWVudC5wcm90b3R5cGUuZ2V0QnlVSUQgPSBmdW5jdGlvbiAodHlwZSwgdWlkLCBvcHRpb25zLCBjYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEFwaSgpLnRoZW4oZnVuY3Rpb24gKGFwaSkgeyByZXR1cm4gYXBpLmdldEJ5VUlEKHR5cGUsIHVpZCwgb3B0aW9ucywgY2IpOyB9KTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbiAodHlwZSwgb3B0aW9ucywgY2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGFwaS5nZXRTaW5nbGUodHlwZSwgb3B0aW9ucywgY2IpOyB9KTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5nZXRCb29rbWFyayA9IGZ1bmN0aW9uIChib29rbWFyaywgb3B0aW9ucywgY2IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBcGkoKS50aGVuKGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGFwaS5nZXRCb29rbWFyayhib29rbWFyaywgb3B0aW9ucywgY2IpOyB9KTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0Q2xpZW50LnByb3RvdHlwZS5nZXRQcmV2aWV3UmVzb2x2ZXIgPSBmdW5jdGlvbiAodG9rZW4sIGRvY3VtZW50SWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnZXREb2NCeUlkID0gZnVuY3Rpb24gKGRvY3VtZW50SWQsIG1heWJlT3B0aW9ucykgeyByZXR1cm4gX3RoaXMuZ2V0QXBpKCkudGhlbihmdW5jdGlvbiAoYXBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcGkuZ2V0QnlJRChkb2N1bWVudElkLCBtYXliZU9wdGlvbnMpO1xyXG4gICAgICAgIH0pOyB9O1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVQcmV2aWV3UmVzb2x2ZXIodG9rZW4sIGRvY3VtZW50SWQsIGdldERvY0J5SWQpO1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRDbGllbnQuZ2V0QXBpID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBhcGkgPSBuZXcgQXBpKHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGFwaS5nZXQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdENsaWVudDtcclxufSgpKTtcblxudmFyIGluZGV4ID0ge1xyXG4gICAgZXhwZXJpbWVudENvb2tpZTogRVhQRVJJTUVOVF9DT09LSUUsXHJcbiAgICBwcmV2aWV3Q29va2llOiBQUkVWSUVXX0NPT0tJRSxcclxuICAgIFByZWRpY2F0ZXM6IFByZWRpY2F0ZXMsXHJcbiAgICBwcmVkaWNhdGVzOiBQcmVkaWNhdGVzLFxyXG4gICAgRXhwZXJpbWVudHM6IEV4cGVyaW1lbnRzLFxyXG4gICAgQXBpOiBBcGksXHJcbiAgICBjbGllbnQ6IGNsaWVudCxcclxuICAgIGdldEFwaTogZ2V0QXBpLFxyXG4gICAgYXBpOiBhcGksXHJcbn07XHJcbmZ1bmN0aW9uIGNsaWVudCh1cmwsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgRGVmYXVsdENsaWVudCh1cmwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFwaSh1cmwsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBEZWZhdWx0Q2xpZW50LmdldEFwaSh1cmwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGFwaSh1cmwsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBnZXRBcGkodXJsLCBvcHRpb25zKTtcclxufVxuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prismicio/client/esm/@prismicio/client.mjs\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);